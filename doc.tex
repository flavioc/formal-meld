\documentclass[9pt]{article}
% \documentclass[11pt,twoside]{article}

\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{comment}
\usepackage{proof-dashed}
\usepackage{url}
\usepackage{amsmath}
\usepackage{turnstile}
\usepackage[in]{fullpage}

\input{fp-macros}

\title{Meld 2.0 Semantics}
\author{Flavio Cruz}

\begin{document}

\newcommand{\defeq}{\buildrel\triangle\over =}
\newcommand{\trnstile}{\sststile{}{}}
\newcommand{\typ}[1]{\m{#1} \; \m{typ}}
\newcommand{\typelist}[1]{\m{#1} \; \m{type \; list}}
\newcommand{\eexpr}[2]{\m{#1}:\m{#2}}
\newcommand{\aexp}[4]{#1;#2 \sststile{}{} \eexpr{#3}{#4}}
\newcommand{\expr}[3]{\aexp{\Psi}{#1}{#2}{#3}}
\newcommand{\tab}[0]{\;\;\;\;}
\newcommand{\elet}[3]{\m{let} \; #1 \; = \; #2 \; \m{in} \; #3 \; \m{end}}
\newcommand{\const}[2]{\m{const}(\mathit{#1}, #2)}
\newcommand{\getconst}[1]{\m{getconst}(\mathit{#1})}
\newcommand{\external}[2]{\m{external}(\mathit{#1}, #2)}
\newcommand{\callexternal}[2]{\m{callexternal}(\mathit{#1}, #2)}
\newcommand{\fun}[3]{\m{fun}(\mathit{#1}, #2, #3)}
\newcommand{\callfun}[2]{\m{callfun}(\mathit{#1}, #2)}
\newcommand{\decl}[2]{\m{decl} \; #1 \; [#2]}
\newcommand{\val}[2]{\m{val} \; #1 : \m{#2}}
\newcommand{\declconst}[3]{\const{#1}{#2} \; \m{of} \; #3}
\newcommand{\declfun}[4]{\fun{#1}{(#2)}{#3} \; \m{of} \; #4}
\newcommand{\eval}[2]{\Psi \; ; \; #1 \rightarrow #2}
\newcommand{\constraint}[1]{\m{constraint} \; #1}
\newcommand{\fact}[3]{#1[@#2](#3)}
\newcommand{\mif}[3]{\m{if} \; #1 \; \m{then} \; #2 \; \m{else} \; #3 \; \m{end}}
\newcommand{\mrule}[4]{\Psi ; #1 ; #2 \vdash_{#4} #3 \; \m{rule}}
\newcommand{\mrulebody}[4]{\Psi ; #1 ; #2 ; #3 \vdash #4 \; \m{body}}
\newcommand{\mrulehead}[4]{\Psi ; #1 ; #2 \vdash_{#4} #3 \; \m{head}}
\newcommand{\mrulestart}[1]{\m{rule} \; \Psi \; / \; #1}
\newcommand{\comp}[0]{\m{comp} \; }
\newcommand{\aggregate}[4]{[\m{#1} ; #2 ; #3 \Rightarrow #4]}
\newcommand{\aggregatetype}[3]{[\m{#1}] \; / \; #2 \rightsquigarrow #3}
\newcommand{\aggregatestart}[2]{[\m{#1}] \hookrightarrow #2}
\newcommand{\aggregateop}[4]{[\m{#1}] \; #2 / #3 \Rightarrow #4}
\newcommand{\changes}[7]{#1 ; #2 ; #3 ; #4 \Rightarrow #5 ; #6 ; #7}
\newcommand{\changesb}[7]{#1 ; #2 ; #3 ; #4 \Rightarrow #5 ; #6 ; #7}
\newcommand{\apply}[6]{\m{apply} \; #1 ; #2 ; #3 \rightarrow #4 ; #5 ; #6}
\newcommand{\applyb}[6]{\m{apply} \; #1 ; #2 ; #3 \rightarrow #4 ; #5 ; #6}
\newcommand{\derive}[8]{\m{derive} \; \Psi ; #1 ; #2 ; #3 ; #4 ; #5 \rightarrow #6 ; #7 ; #8}
\newcommand{\deriveb}[9]{\m{derive} \; #1 ; #2 ; #3 ; #4 ; #5 ; #6 \rightarrow #7 ; #8 ; #9}
\newcommand{\match}[5]{\m{match} \; #1 ; #2 ; #3 \rightarrow #4 ; #5}
\newcommand{\equal}[2]{#1 = #2}
\newcommand{\at}[2]{#1 \; @ \; #2}
\newcommand{\compr}[1]{\m{def} \; #1}
\newcommand{\comprehension}[1]{\comp #1}
\newcommand{\comprrec}[1]{\m{comp2} \; #1}

\maketitle

\section{Static Semantics}

\subsection{Types}

\[
\infer[\m{addr}]
{\typ{addr}}{}
\tab
\infer[\m{int}]
{\typ{int}}
{}
\tab
\infer[\m{float}]
{\typ{float}}
{}
\tab
\infer[\m{bool}]
{\typ{bool}}{}
\tab
\infer[\m{string}]
{\typ{string}}{}
\]

\[
\infer[\m{list}]
{\typ{list \; \tau}}{\typ{\tau}}
\tab
\infer[\m{struct}]
{\typ{struct \; T}}{\typelist{T}}
\]

\[
\infer[\m{type \; list \; end}]
{\typelist{\cdot}}
\tab
\infer[\m{type \; list}]
{\typelist{\tau ; T}}{\typelist{T}}
\]

\subsection{Expressions}

\[
\infer[\m{addr \; literal}]
{\expr{\Gamma}{\m{addr}(N)}{\m{addr}}}
{}
\]

\[
\infer[\m{int \; literal}]
{\expr{\Gamma}{\m{int}(N)}{int}}{\m{N \; is \; a \; literal}}
\tab
\infer[\m{float \; literal}]
{\expr{\Gamma}{\m{float}(F)}{float}}{\m{F \; is \; a \; float \; literal}}
\]

\[
\infer[\m{string \; literal}]
{\expr{\Gamma}{\m{string}(S)}{string}}{\m{S \; is \; a \; string \; literal}}
\tab
\infer[\m{var}]
{\expr{\Gamma, \eexpr{X}{\tau}}{X}{\tau}}{}
\]

\[
\infer[\m{nil}]
{\expr{\Gamma}{[]}{\m{list \; \tau}}}{\m{\tau}}
\tab
\infer[\m{cons}]
{\expr{\Gamma}{[e_1 \; | \; e_2]}{\m{list \; \tau}}}
{\expr{\Gamma}{e_1}{\m{\tau}} &
   \expr{\Gamma}{e_2}{\m{list \; \tau}}}
\]

\[
\infer[\m{make \; struct}]
{\expr{\Gamma}{\m{struct} \; e_1; ...; e_n}{\m{struct \; \tau_1; ...; \tau_n}}}
{\expr{\Gamma}{e_1}{\tau_1} & ... & \expr{\Gamma}{e_n}{\tau_n}}
\tab
\infer[\m{get \; struct}]
{\expr{\Gamma}{\#i(e)}{\tau_i}}
{\expr{\Gamma}{e}{\m{struct \; \tau_1; ...; \tau_n}}}
\]

\[
\infer[\m{math \; int}]
{\expr{\Gamma}{e_1 \; \m{op} \; e_2}{\m{int}}}
{\expr{\Gamma}{e_1}{\m{int}} & \expr{\Gamma}{e_2}{\m{int}}}
\tab
\infer[\m{math \; float}]
{\expr{\Gamma}{e_1 \; \m{op} \; e_2}{\m{float}}}
{\expr{\Gamma}{e_1}{\m{float}} & \expr{\Gamma}{e_2}{\m{float}}}
\]

\[
\infer[\m{math \; cast1}]
{\expr{\Gamma}{e_1 \; \m{op} \; e_2}{\m{float}}}
{\expr{\Gamma}{e_1}{\m{int}} & \expr{\Gamma}{e_2}{\m{float}}}
\tab
\infer[\m{math \; cast2}]
{\expr{\Gamma}{e_1 \; \m{op} \; e_2}{\m{float}}}
{\expr{\Gamma}{e_1}{\m{float}} & \expr{\Gamma}{e_2}{\m{int}}}
\]

\[
\infer[\m{if}]
{\expr{\Gamma}{\mif{c}{e_1}{e_2}}{\tau}}
{\expr{\Gamma}{c}{\m{bool}} &
   \expr{\Gamma}{e_1}{\m{\tau}} &
      \expr{\Gamma}{e_2}{\m{\tau}}}
\]

\[
\infer[\m{cmp} \; \m{int}]
{\expr{\Gamma}{e_1 \; \m{cmp} \; e_2}{\m{bool}}}
{\expr{\Gamma}{e_1}{\m{int}} &
   \expr{\Gamma}{e_2}{\m{int}}}
\tab
\infer[\m{cmp} \; \m{float}]
{\expr{\Gamma}{e_1 \; \m{cmp} \; e_2}{\m{bool}}}
{\expr{\Gamma}{e_1}{\m{float}} &
   \expr{\Gamma}{e_2}{\m{float}}}
\]

\[
\infer[\m{cmp} \; \m{bool}]
{\expr{\Gamma}{e_1 \; \m{cmp} \; e_2}{\m{bool}}}
{\expr{\Gamma}{e_1}{\m{bool}} &
   \expr{\Gamma}{e_2}{\m{bool}}}
\tab
\infer[\m{cmp} \; \m{string}]
{\expr{\Gamma}{e_1 \; \m{cmp} \; e_2}{\m{bool}}}
{\expr{\Gamma}{e_1}{\m{string}} &
   \expr{\Gamma}{e_2}{\m{string}}}
\]

\[
\infer[\m{cmp} \; \m{addr}]
{\expr{\Gamma}{e_1 \; \m{cmp} \; e_2}{\m{bool}}}
{\expr{\Gamma}{e_1}{\m{addr}} &
   \expr{\Gamma}{e_2}{\m{addr}}}
\]

\[
\infer[\m{or}]
{\expr{\Gamma}{e_1 \; \m{or} \; e_2}{\m{bool}}}
{\expr{\Gamma}{e_1}{\m{bool}} & \expr{\Gamma}{e_2}{\m{bool}}}
\]

\[
\infer[\m{let}]
{\expr{\Gamma}{\elet{X}{e_1}{e_2}}{\tau}}
{\expr{\Gamma}{e_1}{\tau_1} &
   \expr{\Gamma, \eexpr{X}{\tau_1}}{e_2}{\tau}}
\]

\[
\infer[\m{const}]
{\aexp{\Psi, \eexpr{\const{name}{v}}{\tau}}{\Gamma}{\getconst{name}}{\tau}}
{}
\]

\[
\infer[\m{external}]
{\expr{\Gamma}{\callexternal{name}{[e_1, ..., e_n]}}{\tau}}
{\expr{\Gamma}{e_1}{\tau_1} & ... & \expr{\Gamma}{e_n}{\tau_n} &
   \eexpr{\external{name}{[arg_1, ..., arg_n]}}{(\tau_1, ..., \tau_n)\overrightarrow{\tau}} \in \Psi
}
\]

\[
\infer[\m{fun}]
{\expr{\Gamma}{\callfun{name}{[e_1, ..., e_n]}}{\tau}}
{\expr{\Gamma}{e_1}{\tau_1} & ... & \expr{\Gamma}{e_n}{\tau_n} &
   \eexpr{\fun{name}{[arg_1, ..., arg_n]}{e}}{(\tau_1, ..., \tau_n)\overrightarrow{\tau}} \in \Psi
}
\]

\[
\infer[\m{world}]
{\expr{\Gamma}{\m{world}}{\m{int}}}
{}
\tab
\infer[\m{arg}]
{\expr{\Gamma}{\m{arg}(N)}{\m{string}}}
{}
\]

\subsection{Declarations}

\[
\infer[\m{decl}]
{\decl{name}{\m{addr}, \tau_1, ..., \tau_n}}
{\typ{addr} & \typ{\tau_1} & ... & \typ{\tau_n}}
\tab
\infer[\m{\bang decl}]
{\bang\decl{name}{\m{addr}, \tau_1, ..., \tau_n}}
{\typ{addr} & \typ{\tau_1} & ... & \typ{\tau_n}}
\]

\[
\infer[\m{const}]
{\declconst{name}{v}{\tau}}
{\expr{\Gamma}{e}{\tau} & \eval{e}{v} & \val{v}{\tau}}
\]

\[
\infer[\m{fun}]
{\declfun{name}{arg_1 : \tau_1, ..., arg_n : \tau_n}{e}{\tau}}
{\expr{arg_1 : \tau_1, ..., arg_n : \tau_n}{e}{\tau}}
\]

\subsection{Rules}

\[
\infer[\m{rule \; start}]
{\mrulestart{\forall H : \m{addr}. A}}
{\mrule{\cdot}{H}{A}{1}}
\]

\[
\infer[\m{rule \; add \; var}]
{\mrule{\Gamma}{H}{\forall X : \tau. A}{N}}
{\mrule{\Gamma, X : \tau}{H}{A}{N}}
\]

\[
\infer[\m{rule \; body \; head}]
{\mrule{\Gamma}{H}{A \lolli B}{N}}
{\mrulebody{\Gamma, H : \m{addr}}{H}{\Gamma}{A} & \mrulehead{\Gamma, H:\m{addr}}{H}{B}{N}}
\]

\[
\infer[\m{rule \; body \; tensor}]
{\mrulebody{\Gamma}{H}{\Gamma', \Gamma''}{A \otimes B}}
{\mrulebody{\Gamma}{H}{\Gamma''}{B} &
   \mrulebody{\Gamma}{H}{\Gamma'}{A} & }
\]

\[
\infer[\m{rule \; body \; 1}]
{\mrulebody{\Gamma}{H}{\cdot}{1}}
{}
\]

\[
\infer[\m{rule \; body \; exists}]
{\mrulebody{\Gamma}{H}{\Gamma'}{\exists X : \tau. A}}
{\mrulebody{\Gamma, X : \tau}{H}{\Gamma', X : \tau}{A}}
\]

\[
\infer[\m{rule \; body \; fact}]
{\mrulebody{\Gamma, H_{fact} : \m{addr}}{H}{X_1 : \tau_1, ..., X_n : \tau_n}{\fact{name}{H_{fact}}{X_1, ..., X_n}}}
{\decl{name}{\m{addr}, \tau_1, ..., \tau_n} \in \Psi}
\]


\[
\infer[\m{rule \; body \; \bang fact}]
{\mrulebody{\Gamma, H_{fact} : \m{addr}}{H}{X_1 : \tau_1, ..., X_n : \tau_n}{\bang\fact{name}{H_{fact}}{X_1, ..., X_n}}}
{\bang\decl{name}{\m{addr}, \tau_1, ..., \tau_n} \in \Psi}
\]

\[
\infer[\m{rule}]
{\mrulebody{\Gamma}{H}{\cdot}{\bang (\constraint{e})}}
{\expr{\Gamma}{e}{\m{bool}}}
\]

\[
\infer[\m{rule \; head \; tensor}]
{\mrulehead{\Gamma}{H}{A \otimes B}{N}}
{\mrulehead{\Gamma}{H}{A}{N} & \mrulehead{\Gamma}{H}{B}{N}}
\]

\[
\infer[\m{rule \; head \; 1}]
{\mrulehead{\Gamma}{H}{\m{1}}{N}}
{}
\]

\[
\infer[\m{rule \; head \; fact}]
{\mrulehead{\Gamma}{H}{\fact{name}{e}{e_1, ..., e_n}}{N}}
{\expr{\Gamma}{e}{\m{addr}} & \expr{\Gamma}{e_1}{\tau_1} & ... & \expr{\Gamma}{e_n}{\tau_n} &
   \decl{name}{\m{addr}, \tau_1, ..., \tau_n} \in \Psi}
\]

\[
\infer[\m{rule \; head \; \bang fact}]
{\mrulehead{\Gamma}{H}{\bang\fact{name}{e}{e_1, ..., e_n}}{N}}
{\expr{\Gamma}{e}{\m{addr}} & \expr{\Gamma}{e_1}{\tau_1} & ... & \expr{\Gamma}{e_n}{\tau_n} &
   \bang\decl{name}{\m{addr}, \tau_1, ..., \tau_n} \in \Psi}
\]

\[
\infer[\m{rule \; head \; exists}]
{\mrulehead{\Gamma}{H}{\exists X : \m{addr}. A}{N}}
{\mrulehead{\Gamma, X : \m{addr}}{H}{A}{N}}
\]

\[
\infer[\m{rule \; head \; comprehension}]
{\mrulehead{\Gamma}{H}{\comprehension{A}}{1}}
{\mrule{\Gamma}{H}{A}{2}}
\]

\[
\infer[\m{rule \; head \; aggregate}]
{\mrulehead{\Gamma}{H}{\aggregate{Op}{X}{A}{B}}{1}}
{\aggregatetype{Op}{\tau_1}{\tau_2} & \mrule{\Gamma, X : \tau_1}{H}{A \lolli 1}{2} & \mrulehead{\Gamma, X : \tau_2}{H}{B}{2}}
\]

\subsection{Aggregate Types}

\[
\infer[\m{agg \; count}]
{\aggregatetype{count}{\m{int}}{\m{int}}}
{}
\tab
\infer[\m{agg \; collect \; int}]
{\aggregatetype{collect \; int}{\m{int}}{\m{list \; int}}}
{}
\]

\[
\infer[\m{agg \; int \; sum}]
{\aggregatetype{sum \; int}{\m{int}}{\m{int}}}
{}
\]

\[
\infer[\m{agg \; int \; max}]
{\aggregatetype{max \; int}{\m{int}}{\m{int}}}
{}
\tab
\infer[\m{agg \; int \; min}]
{\aggregatetype{min \; int}{\m{int}}{\m{int}}}
{}
\]

\section{Dynamic Semantics}

\subsection{Expression Values}

\[
\infer[\m{int}]
{\val{\m{int}(N)}{int}}
{}
\tab
\infer[\m{bool}]
{\val{\m{bool}(B)}{bool}}
{}
\tab
\infer[\m{float}]
{\val{\m{float}(F)}{float}}
{}
\]

\[
\infer[\m{string}]
{\val{\m{string}(S)}{string}}
{}
\tab
\infer[\m{addr}]
{\val{\m{addr}(A)}{addr}}
{}
\]

\[
\infer[\m{nil}]
{\val{[]}{list \; \tau}}
{}
\tab
\infer[\m{cons}]
{\val{x :: ls}{list \; \tau}}
{\val{x}{\tau} & \val{ls}{list \; \tau}}
\]

\[
\infer[\m{struct}]
{\val{:(v_1, ..., v_n)}{\m{struct \; \tau_1; ...; \tau_n}}}
{\val{v_1}{\tau_1} & ... & \val{v_n}{\tau_n}}
\]

\subsection{Expression Evaluation}

\[
\infer[\m{int}]
{\eval{\m{int}(N)}{\m{int}(N)}}
{}
\tab
\infer[\m{float}]
{\eval{\m{float}(F)}{\m{float}(F)}}
{}
\tab
\infer[\m{addr}]
{\eval{\m{addr}(A)}{\m{addr}(A)}}
{}
\]

\[
\infer[\m{bool}]
{\eval{\m{bool}(B)}{\m{bool}(B)}}
{}
\]

\[
\infer[\m{string}]
{\eval{\m{string}(S)}{\m{string}(S)}}
{}
\tab
\infer[\m{list\; nil}]
{\eval{[]}{[]}}
{}
\tab
\infer[\m{list}]
{\eval{L}{L}}
{}
\]

\[
\infer[\m{cons}]
{\eval{[e_1 | e_2]}{v_1 :: v_2}}
{\eval{e_1}{v_1} & \eval{e_2}{v_2}}
\]

\[
\infer[\m{make \; struct}]
{\eval{\m{struct \; e_1; ...; e_n}}{:(v_1; ...; v_n)}}
{\eval{e_1}{v_1} & ... & \eval{e_n}{v_n}}
\]

\[
\infer[\m{get \; struct}]
{\eval{\m{\#i(e)}}{v_i}}
{\eval{e}{:(v_1; ...; v_i ; ... ; v_n)}}
\]

\[
\infer[\m{math \; int}]
{\eval{e_1 \; \m{op} \; e_2}{\m{int}(V)}}
{\expr{\cdot}{e_1}{\m{int}} & \expr{\cdot}{e_2}{\m{int}} & \eval{e_1}{\m{int}(A)} & \eval{e_2}{\m{int}(B)} &
   V = A \; \m{op} \; B}
\]

\[
\infer[\m{math \; float}]
{\eval{e_1 \; \m{op} \; e_2}{\m{float}(V)}}
{\expr{\cdot}{e_1}{\m{float}} & \expr{\cdot}{e_2}{\m{float}} &
   \eval{e_1}{\m{float}(A)} & \eval{e_2}{\m{float}(B)} &
   V = A \; \m{op} \; B}
\]

\[
\infer[\m{math \; cast1}]
{\eval{e_1 \; \m{op} \; e_2}{\m{float}(V)}}
{\expr{\cdot}{e_1}{\m{int}} & \expr{\cdot}{e_2}{\m{float}} &
   \eval{e_1}{\m{int}(A)} & \eval{e_2}{\m{float}(B)} &
   V = A \; \m{op} \; B}
\]

\[
\infer[\m{math \; cast2}]
{\eval{e_1 \; \m{op} \; e_2}{\m{float}(V)}}
{\expr{\cdot}{e_1}{\m{float}} & \expr{\cdot}{e_2}{\m{int}} &
   \eval{e_1}{\m{float}(A)} & \eval{e_2}{\m{int}(B)} &
   V = A \; \m{op} \; B}
\]

\[
\infer[\m{if \; true}]
{\eval{\mif{c}{e_1}{e_2}}{v_1}}
{\eval{c}{\m{bool}(true)} &
   \eval{e_1}{v_1}}
\tab
\infer[\m{if \; false}]
{\eval{\mif{c}{e_1}{e_2}}{v_2}}
{\eval{c}{\m{bool}(false)} &
   \eval{e_2}{v_2}}
\]

\[
\infer[\m{cmp \; int}]
{\eval{e_1 \; \m{cmp} \; e_2}{\m{bool}(V)}}
{\eval{e_1}{\m{int}(A)} &
   \eval{e_2}{\m{int}(B)} &
   V = A \; \m{cmp} \; B
}
\]

\[
\infer[\m{cmp \; float}]
{\eval{e_1 \; \m{cmp} \; e_2}{\m{bool}(V)}}
{\eval{e_1}{\m{float}(A)} &
   \eval{e_2}{\m{float}(B)} &
   V = A \; \m{cmp} \; B
}
\]

\[
\infer[\m{cmp \; bool}]
{\eval{e_1 \; \m{cmp} \; e_2}{\m{bool}(V)}}
{\eval{e_1}{\m{bool}(A)} &
   \eval{e_2}{\m{bool}(B)} &
   V = A \; \m{cmp} \; B
}
\]

\[
\infer[\m{cmp \; string}]
{\eval{e_1 \; \m{cmp} \; e_2}{\m{bool}(V)}}
{\eval{e_1}{\m{string}(A)} &
   \eval{e_2}{\m{string}(B)} &
   V = A \; \m{cmp} \; B
}
\]

\[
\infer[\m{cmp \; addr}]
{\eval{e_1 \; \m{cmp} \; e_2}{\m{bool}(V)}}
{\eval{e_1}{\m{addr}(A)} &
   \eval{e_2}{\m{addr}(B)} &
   V = A \; \m{cmp} \; B
}
\]

\[
\infer[\m{or}]
{\eval{e_1 \; \m{or} \; e_2}{\m{bool}(V)}}
{\eval{e_1}{\m{bool}(A)} &
   \eval{e_2}{\m{bool}(B)} &
   V = A \; \m{or} \; B
}
\]

\[
\infer[\m{let}]
{\eval{\elet{X}{e_1}{e_2}}{v}}
{\eval{e_1}{v_1} &
   \eval{[v_1/x]e_2}{v}}
\]

\[
\infer[\m{const}]
{\eval{\getconst{name}}{v}}
{\const{name}{v} : \tau \in \Psi}
\]

\[
\infer[\m{external}]
{\eval{\callexternal{name}{[e_1, ..., e_n]}}{v}}
{\begin{array}{ccc}
   \eval{e_1}{v_1} & ... & \eval{e_n}{v_n} \\
   \multicolumn{3}{c}{\eexpr{\external{name}{[arg_1, ..., arg_n]}}{(\tau_1, ..., \tau_n)\overrightarrow{\tau}} \in \Psi} \\
   \multicolumn{3}{c}{v = \callexternal{name}{[v_1, ..., v_n]}} \\
 \end{array}
}
\]

\[
\infer[\m{fun}]
{\eval{\callfun{name}{[e_1, ..., e_n]}}{v}}
{\begin{array}{ccc}
   \eval{e_1}{v_1} & ... & \eval{e_n}{v_n} \\
   \multicolumn{3}{c}{\eexpr{\fun{name}{[arg_1, ..., arg_n]}{e}}{(\tau_1, ..., \tau_n)\overrightarrow{\tau}} \in \Psi} \\
   \multicolumn{3}{c}{\eval{[v_1/\m{arg}_1]...[v_n/\m{arg}_n]e}{v}} \\
   \multicolumn{3}{c}{v = \callfun{name}{v_1, ..., v_n}} \\
 \end{array}
}
\]

\[
\infer[\m{world}]
{\eval{\m{world}}{\m{int}(N)}}
{}
\tab
\infer[\m{arg}]
{\eval{\m{arg}(N)}{\m{string}(S)}}
{}
\]

\subsection{Aggregates}

\[
\infer[\m{init \; count}]
{\aggregatestart{count}{\m{int}(0)}}
{}
\]

\[
\infer[\m{init \; collect \; int}]
{\aggregatestart{collect \; int}{[]}}
{}
\]

\[
\infer[\m{init \; sum}]
{\aggregatestart{sum}{\m{int}(0)}}
{}
\tab
\infer[\m{init \; max}]
{\aggregatestart{max}{\m{int}(-\infty)}}
{}
\tab
\infer[\m{init \; min}]
{\aggregatestart{min}{\m{int}(+\infty)}}
{}
\]

\[
\infer[\m{op \; sum}]
{\aggregateop{sum}{A}{B}{A + B}}
{}
\]

\[
\infer[\m{op \; count}]
{\aggregateop{count}{A}{B}{A + 1}}
{}
\]

\[
\infer[\m{op \; collect \; int}]
{\aggregateop{collect \; int}{A}{B}{[B | A]}}
{}
\]

\[
\infer[\m{op \; min}]
{\aggregateop{min}{A}{B}{\mif{A \leq B}{A}{B}}}
{}
\]

\[
\infer[\m{op \; max}]
{\aggregateop{max}{A}{B}{\mif{A \leq B}{B}{A}}}
{}
\]


\subsection{Global Semantics}

Meaning of variables:

\begin{description}
\item[$\Psi$]: Program state: constants, functions, external functions and declarations.
\item[$\Theta$]: Rules with priority.
\item[$\Phi$]: Rules without priority.
\item[$\Gamma$]: Persistent fact context.
\item[$\Delta$]: Linear fact context.
\end{description}

\[
\infer[\m{rule \; app}]
{\changes{\Psi}{\Theta, \Phi, R}{\Gamma}{\Delta}{\Gamma'}{\Delta'}{\Xi}}
{\apply{\Psi}{\Gamma}{\Delta, [R]}{\Gamma'}{\Delta'}{\Xi}}
\]

\[
\infer[\m{\lolli L}]
{\apply{\Psi}{\Gamma}{\Delta_1, \Delta_2, [A \lolli B]}{\Gamma'}{\Delta'}{\Delta_1, \Xi}}
{\match{\Psi}{\Gamma}{\Delta_1}{[A]}{\Delta_1} &
   \derive{\Gamma}{\Delta_2}{[B]}{\cdot}{\cdot}{\Gamma'}{\Delta'}{\Xi}
}
\]

\[
\infer[\m{\forall L}]
{\apply{\Psi}{\Gamma}{\Delta, [\forall X : \tau. A]}{\Gamma'}{\Delta'}{\Xi}}
{\val{M}{\tau} & \apply{\Psi}{\Gamma}{\Delta, [A\{M/X\}]}{\Gamma'}{\Delta'}{\Xi}}
\]

\subsubsection{Match}

\[
\infer[\m{match \; exists}]
{\match{\Psi}{\Gamma}{\Delta}{[\exists X. A]}{\Xi}}
{\match{\Psi}{\Gamma}{\Delta}{[[M/X]A]}{\Xi}}
\]

\[
\infer[\m{match \; one}]
{\match{\Psi}{\Gamma}{\cdot}{[1]}{\cdot}}
{}
\]

\[
\infer[\m{match \; split}]
{\match{\Psi}{\Gamma}{\Delta, \Delta'}{[A \otimes B]}{\Xi_1, \Xi_2}}
{\match{\Psi}{\Gamma}{\Delta}{[A]}{\Xi_1} &
   \match{\Psi}{\Gamma}{\Delta'}{[B]}{\Xi_2}
}
\]

\[
\infer[\m{match \; end \; constraint}]
{\match{\Psi}{\Gamma}{\cdot}{[\bang\constraint{e}]}{\cdot}}
{\eval{e}{\m{bool}(\m{true})}}
\]

\[
\infer[\m{match \; end \; linear}]
{\match{\Psi}{\Gamma}{\fact{name}{v_1}{v_2, ..., v_n}}{[\fact{name}{v_1}{v_2, ..., v_n}]}{\fact{name}{v_1}{v_2, ..., v_n}}}
{\equal{v_1}{v_1'} & ... & \equal{v_n}{v_n'}}
\]
%% do I need a val here?

\[
\infer[\m{match \; end \; persistent}]
{\match{\Psi}{\Gamma, \bang\fact{name}{v_1}{v_2, ..., v_n}}{\cdot}{[\bang\fact{name}{v_1'}{v_2', ..., v_n'}]}{\cdot}}
{\equal{v_1}{v_1'} & ... & \equal{v_n}{v_n'}}
\]

\[
\infer[\m{equal \; int}]
{\equal{\m{int}(N)}{\m{int}(N)}}
{}
\tab
\infer[\m{equal \; float}]
{\equal{\m{float}(F)}{\m{float}(F)}}
{}
\tab
\infer[\m{equal \; addr}]
{\equal{\m{addr}(A)}{\m{addr}(A)}}
{}
\]

\[
\infer[\m{equal \; string}]
{\equal{\m{string}(S)}{\m{string}(S)}}
{}
\tab
\infer[\m{equal \; bool}]
{\equal{\m{bool}(B)}{\m{bool}(B)}}
{}
\]

\[
\infer[\m{equal \; nil}]
{\equal{[]}{[]}}
{}
\tab
\infer[\m{equal \; cons}]
{\equal{x :: ls}{x' :: ls'}}
{\equal{x}{x'} & \equal{ls}{ls'}}
\]

\subsection{Derive}

\[
\infer[\m{derive \; blur}]
{\derive{\Gamma}{\Delta}{[A]}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
{\derive{\Gamma}{\Delta}{A}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
\]

\[
\infer[\m{derive \; \otimes}]
{\derive{\Gamma}{\Delta}{A \otimes B, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
{\derive{\Gamma}{\Delta}{A, B, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
\]

\[
\infer[\m{derive \; exists}]
{\derive{\Gamma}{\Delta}{\exists X : \m{addr}. A, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
{\derive{\Gamma}{\Delta}{[x/X]A, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi} &
   x = \m{new} \; \m{addr}(A)}
\]

\[
\infer[\m{derive \; fact}]
{\derive{\Gamma}{\Delta}{\fact{name}{e_1}{e_2, ..., e_n}, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
{\begin{array}{ccc}
   \eval{e_1}{v_1} & ... & \eval{e_n}{v_n} \\
   \multicolumn{3}{c}{\derive{\Gamma}{\Delta}{\Omega}{\Delta_1, \fact{name}{v_1}{v_2, ..., v_n}}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}} \\
   \end{array}
}
\]

\[
\infer[\m{derive \; \bang fact}]
{\derive{\Gamma}{\Delta}{\bang\fact{name}{e_1}{e_2, ..., e_n}, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
{\begin{array}{ccc}
   \eval{e_1}{v_1} & ... & \eval{e_n}{v_n} \\
   \multicolumn{3}{c}{\derive{\Gamma}{\Delta}{\Omega}{\Delta_1}{\Gamma_1, \bang\fact{name}{v_1}{v_2, ..., v_n}}{\Gamma'}{\Delta'}{\Xi}} \\
   \end{array}
}
\]

\[
\infer[\m{derive \; 1}]
{\derive{\Gamma}{\Delta}{1, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
{\derive{\Gamma}{\Delta}{\Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
\]

\[
\infer[\m{derive \; comprehension}]
{\derive{\Gamma}{\Delta}{\comprehension{A}, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
{\derive{\Gamma}{\Delta}{1 \with (A \otimes \comprehension{A}), \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
\]


\[
\infer[\m{derive \; \with \; left}]
{\derive{\Gamma}{\Delta}{A \with B, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
{\derive{\Gamma}{\Delta}{A, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
\]

\[
\infer[\m{derive \; \with \; right}]
{\derive{\Gamma}{\Delta}{A \with B, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
{\derive{\Gamma}{\Delta}{B, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
\]

\newcommand{\aggdef}[4]{\m{agg} \; \m{#1} \; #2 \; #3 \; #4}

\[
\infer[\m{derive \; aggregate}]
{\derive{\Gamma}{\Delta}{\aggregate{Op}{X}{A}{B}, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
{\aggregatestart{Op}{V} & \derive{\Gamma}{\Delta}{\aggdef{Op}{V}{(x. A(x))}{(y. B(y))}, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
\]

\[
\infer[\m{derive \; aggregate \; unfold}]
{\derive{\Gamma}{\Delta}{\aggdef{Op}{V'}{(x. A(x))}{(y. B(y))}, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
{\derive{\Gamma}{\Delta}{B(V) \with (\forall X'. A(X') \lolli \aggdef{Op}{E}{(x. A(x))}{(y. B(y))}), \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi} & \aggregateop{Op}{V'}{X'}{E}
}
\]

\[
\infer[\m{derive \; forall}]
{\derive{\Gamma}{\Delta}{\forall X : \tau. A, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}}
{\derive{\Gamma}{\Delta}{[M/X]A, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi} & \val{M}{\tau}}
\]

\[
\infer[\m{derive \; lolli}]
{\derive{\Gamma}{\Delta}{A \lolli B, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi, \Xi'}}
{\match{\Psi}{\Gamma}{\Delta}{A}{\Xi'} &
   \derive{\Gamma}{\Delta - \Xi'}{B, \Omega}{\Delta_1}{\Gamma_1}{\Gamma'}{\Delta'}{\Xi}
}
\]

\[
\infer[\m{derive \; end}]
{\derive{\Gamma}{\Delta}{\cdot}{\Delta_1}{\Gamma_1}{\Gamma_1}{\Delta_1}{\cdot}}
{}
\]

\subsection{Local Semantics}

\[
\infer[\m{rule \; app}]
{\at{\changes{\Psi}{\Theta, R}{\Gamma}{\Delta}{\Gamma, \Gamma'}{\Delta', N}}{\pi}}
{\at{\apply{\Psi}{\Gamma}{\Delta, [R]}{\Gamma'}{\Delta'}{\Xi}}{\pi} & N = \Delta - \Xi}
\]

\[
\infer[\m{\lolli L}]
{\at{\apply{\Psi}{\Gamma}{\Delta_1, \Delta_2, [A \lolli B]}{\Gamma'}{\Delta'}{\Xi}}{\pi}}
{\at{\match{\Psi}{\Gamma}{\Delta_1}{[A]}{\Xi}}{\pi} &
   \derive{\Gamma}{\Delta_2}{[B]}{\cdot}{\cdot}{\Gamma'}{\Delta'}{\Xi}}
\]

\[
\infer[\m{\forall L}]
{\at{\apply{\Psi}{\Gamma}{\Delta, [\forall X : \tau. A]}{\Gamma'}{\Delta'}{\Xi}}{\pi}}
{\val{M}{\tau} & \at{\apply{\Psi}{\Gamma}{\Delta, [A\{M/X\}]}{\Gamma'}{\Delta'}{\Xi}}{\pi}}
\]

\subsubsection{Match}

\[
\infer[\m{match \; exists}]
{\at{\match{\Psi}{\Gamma}{\Delta}{[\exists X. A]}{\Xi}}{\pi}}
{\at{\match{\Psi}{\Gamma}{\Delta}{[[M/X]A]}{\Xi}}{\pi}}
\]

\[
\infer[\m{match \; one}]
{\at{\match{\Psi}{\Gamma}{\cdot}{[1]}{\cdot}}{\pi}}
{}
\]

\[
\infer[\m{match \; split}]
{\at{\match{\Psi}{\Gamma}{\Delta, \Delta'}{[A \otimes B]}{\Xi_1, \Xi_2}}{\pi}}
{\at{\match{\Psi}{\Gamma}{\Delta}{[A]}{\Xi_1}}{\pi} &
   \at{\match{\Psi}{\Gamma}{\Delta'}{[B]}{\Xi_2}}{\pi}}
\]

\[
\infer[\m{match \; end \; constraint}]
{\at{\match{\Psi}{\Gamma}{\cdot}{[\bang\constraint{e}]}{\cdot}}{\pi}}
{\eval{e}{\m{bool}(\m{true})}}
\]

\[
\infer[\m{match \; end \; linear}]
{\at{\match{\Psi}{\Gamma}{\fact{name}{v_1}{v_2, ..., v_n}}{[\fact{name}{v_1}{v_2, ..., v_n}]}{\fact{name}{v_1}{v_2, ..., v_n}}}{\pi}}
{\equal{v_1}{v_1'} & ... & \equal{v_n}{v_n'} & v_1 = \m{addr}(\pi)}
\]
%% do I need a val here?

\[
\infer[\m{match \; end \; persistent}]
{\at{\match{\Psi}{\Gamma, \bang\fact{name}{v_1}{v_2, ..., v_n}}{\cdot}{[\bang\fact{name}{v_1'}{v_2', ..., v_n'}]}{\cdot}}{\pi}}
{\equal{v_1}{v_1'} & ... & \equal{v_n}{v_n'} & v_1 = \m{addr}(\pi)}
\]

\begin{comment}
\section{Comprehensions}

Comprehensions have the following syntax:

\begin{verbatim}
body -o {Var-List | CompBody | CompHead}.
\end{verbatim}

We can distinguish between two types of comprehensions:

\subsection{Persistent Only Comprehensions}

These comprehensions only use persistent facts in the body. The head may have linear facts.
Since we only use persistent facts, we are unable to check if we are done with the comprehension just by being unable to do further matchings.
Thus, the only way to check for a stop condition is to verify repeated variables in \texttt{CompBody}.

\begin{verbatim}
body(A) -o {X1, X2, X3 | !a(A, X1), !b(A, X2), !c(A, X3) | CompHead}

// is transformed into
body(A) -o do_comp(A, CommVar1, ..., CommVarN, []).

do_comp(A, CommVar1, ..., CommVarN, L),
!a(A, X1),
!b(A, X2),
!c(A, X3),
(X1, X2, X3) not in L
   -o do_comp(A, CommVar1, ..., CommVarN, [(X1, X2, X3) | L]),
      CompHead.
      
do_comp(A, CommVar1, ..., CommVarN, L) -o 1.
\end{verbatim}

This suffers from a few flaws though. In one hand, we may have several \texttt{!a(A, X1)}, where \texttt{X1} has the same value. With this scheme,
only one \texttt{CompHead} will be derived. On another hand, if \texttt{CompHead} also derives anything that is used in the body of the comprehension, the comprehension may never terminate, so we must constraint \texttt{CompHead} to not include predicates used in the body.

\subsection{Comprehensions with linear facts}

When the comprehension body also contains linear facts we may use another strategy, where we consume all the linear facts to derive all the possible comprehension heads.

\begin{verbatim}
body(A) -o {X1, X2, X3 | !a(A, X1), !b(A, X2), c(A, X3) | CompHead}.

// is transformed into
body(A) -o do_comp(A, CommVar1, ..., CommVarN).

do_comp(A, CommVar1, ..., CommVarN),
!a(A, X1),
!b(A, X2),
c(A, X3)
   -o do_comp(A, CommVar1, ..., CommVarN),
      CompHead.
      
do_comp(A, CommVar1, ..., CommVarN) -o 1.
\end{verbatim}

Of course, we can also use the other approach.

As I said before, problems will arise if \texttt{CompHead} uses predicates from \texttt{CompBody}, because the comprehension may not terminate.
\end{comment}

\subsection{Extending Linear Logic with Comprehensions}

\[
\m{comp} \; A \; B \defeq 1 \; \& \; ((\forall X. A \lolli B) \otimes \m{comp} \; A \; B)
\]

\[
\m{agg} \; V \; A \; C \defeq C \; \& \; (\forall X. A \lolli \m{agg} \; (X + V) \; A \; C)
\]

An example from Meld:

\begin{verbatim}
a(H) -o [sum => S | B | !edge(H, B), !weight(H, B, S) | total(H, S)].

a(H) -o agg1(H, 0).

agg1(H, V) := total(H, V) &
             (forall B, S. !edge(H, B), !weight(H, B, S) -o agg1(H, S + V)).
\end{verbatim}


These would be the left and right rules for definitions:

\[
\infer[\m{def} \; L]
{\Delta, \compr{A'} \trnstile C}
{
   \Delta, B\theta \trnstile C & A \defeq B & A' \doteq A\theta
}
\]

\[
\infer[\m{def} \; R]
{\Delta \trnstile \compr{A'}}
{\Delta \trnstile B \theta & A \defeq B & A' \doteq A\theta}
\]

Identity expansion:

\[
\infer[\m{def} \; R]
{\compr{A'} \trnstile \compr{A'}}
{
   \infer[\m{def} \; L]
   {
      \compr{A'} \trnstile B\theta
   }
   {
      \infer[\m{id}]
      {B \theta \trnstile B \theta}
      {
      }
      & A \defeq B & A' \doteq A\theta
   }
   & A \defeq B & A' \doteq A \theta
}
\]

Cut reduction:

\[
\infer[\m{cut}]
{\Delta \trnstile C}
{
   \infer[\m{def} \; R]
   {
      \Delta \trnstile \compr{A'}
   }
   {
      \Delta \trnstile B\theta & A \defeq B & A' \doteq A'\theta
   }
   &
   \infer[\m{def} \; L]
   {
      \Delta, \compr{A'} \trnstile C
   }
   {
      \Delta, B\theta \trnstile C & A \defeq B & A'\doteq A\theta
   }
}
\]

Reduces to:

\[
\infer[\m{cut}]
{\Delta \trnstile C}
{\Delta, B\theta \trnstile C
   &
   \Delta \trnstile B\theta
}
\]

\begin{comment}
\section{Aggregates}

Aggregates have the following syntax form:

\begin{verbatim}
body(A) -o [op => F | Var-List | CompBody(A) | CompHead(A, F)}.
\end{verbatim}

Like comprehensions, we may distinguish between two types of aggregates.

\subsection{Persistent Only Aggregates}

For these types of aggregates we only use persistent facts in the body.
The transformation verifies that the variable combination has not been tried before and then applies the operator function.

\begin{verbatim}
body(A) -o [sum => W | B | !edge(A, B, W) | total(A, W)].

// is transformed into

body(A) -o do_aggregate(A, CommVar1, ..., CommVarN, 0, []).

do_aggregate(A, CommVar1, ..., CommVarN, Sum, L),
!edge(A, B, W),
(B, W) not in L
   -o do_aggregate(A, CommVar1, ..., CommVarN, Sum + W, [(B, W) | L]).
   
do_aggregate(A, CommVar1, ..., CommVarN, Sum, L) -o total(A, Sum).
\end{verbatim}

\subsection{Aggregates with linear facts}

In this case, the aggregate uses linear facts. We don't need to restrict the predicates used in the body/head since there's only a body.

\begin{verbatim}
body(A) -o [sum => W | B | !edge(A, B), weight(A, B, W) | total(A, W)].

// is transformed into

body(A) -o do_aggregate(A, CommVar1, ..., CommVarN, 0).

do_aggregate(A, CommVar1, ..., CommVarN, Sum),
!edge(A, B),
weight(A, B, W)
   -o do_aggregate(A, CommVar1, ..., CommVarN, Sum + W).
   
do_aggregate(A, CommVar1, ..., CommVarN, Sum) -o total(A, Sum).
\end{verbatim}
\end{comment}

\section{Linear Logic}

\newcommand{\sequent}[3]{#1 ; #2 \vdash #3}
\newcommand{\seqnocut}[3]{#1 ; #2 \Rightarrow #3}

\[
\infer[\one R]
{\sequent{\Gamma}{\cdot}{\one}}
{}
\tab
\infer[\one L]
{\sequent{\Gamma}{\Delta, \one}{C}}
{\sequent{\Gamma}{\Delta}{C}}
\]

\[
\infer[\with R]
{\sequent{\Gamma}{\Delta}{A \with B}}
{\sequent{\Gamma}{\Delta}{A} & \sequent{\Gamma}{\Delta}{B}}
\tab
\infer[\with L_1]
{\sequent{\Gamma}{\Delta, A \with B}{C}}
{\sequent{\Gamma}{\Delta, A}{C}}
\tab
\infer[\with L_2]
{\sequent{\Gamma}{\Delta, B \with B}{C}}
{\sequent{\Gamma}{\Delta, B}{C}}
\]

\[
\infer[\otimes R]
{\sequent{\Gamma}{\Delta, \Delta'}{A \otimes B}}
{\sequent{\Gamma}{\Delta}{A} & \sequent{\Gamma}{\Delta}{B}}
\tab
\infer[\otimes L]
{\sequent{\Gamma}{\Delta, A \otimes B}{C}}
{\sequent{\Gamma}{\Delta, A, B}{C}}
\]

\[
\infer[\lolli R]
{\sequent{\Gamma}{\Delta}{A \lolli B}}
{\sequent{\Gamma}{\Delta, A}{B}}
\tab
\infer[\lolli L]
{\sequent{\Gamma}{\Delta, \Delta', A \lolli B}{C}}
{\sequent{\Gamma}{\Delta}{A} &
   \sequent{\Gamma}{\Delta', B}{C}}
\]

\[
\infer[\forall R]
{\Psi ; \sequent{\Gamma}{\Delta}{\forall n:\tau. A}}
{\Psi, m:\tau ; \sequent{\Gamma}{\Delta}{A\{m/n\}}}
\tab
\infer[\forall L]
{\Psi ; \sequent{\Gamma}{\Delta, \forall n:\tau. A}{C}}
{\Psi \vdash M : \tau & \Psi ; \sequent{\Gamma}{\Delta, A\{M/n\}}{C}}
\]

\[
\infer[\exists R]
{\Psi \; \sequent{\Gamma}{\Delta}{\exists n: \tau. A}}
{\Psi \vdash M : \tau &
   \Psi \; \sequent{\Gamma}{\Delta}{A \{M/n\}}}
\tab
\infer[\exists L]
{\Psi ; \sequent{\Gamma}{\Delta, \exists n:\tau. A}{C}}
{\Psi, m:\tau ; \sequent{\Gamma}{\Delta, A\{m/n\}}{C}}
\]

\[
\infer[\bang R]
{\sequent{\Gamma}{\cdot}{\bang A}}
{\sequent{\Gamma}{\cdot}{A}}
\tab
\infer[\bang L]
{\sequent{\Gamma}{\Delta, \bang A}{C}}
{\sequent{\Gamma, A}{\Delta}{C}}
\tab
\infer[\m{copy}]
{\sequent{\Gamma, A}{\Delta}{C}}
{\sequent{\Gamma, A}{\Delta, A}{C}}
\]

\[
\infer[\m{def} \; R]
{\sequent{\Gamma}{\Delta}{\compr{A'}}}
{\sequent{\Gamma}{\Delta}{B\theta} &
 A \defeq B & A' \doteq A\theta}
\tab
\infer[\m{def} \; L]
{\sequent{\Gamma}{\Delta, \compr{A'}}{C}}
{
   \sequent{\Gamma}{\Delta, B\theta}{C} & A \defeq B & A' \doteq A\theta
}
\]

\[
\infer[\m{cut}]
{\sequent{\Gamma}{\Delta, \Delta'}{C}}
{\sequent{\Gamma}{\Delta}{A} &
   \sequent{\Gamma}{\Delta', A}{C}}
\tab
\infer[\m{cut}\bang]
{\sequent{\Gamma}{\Delta}{C}}
{\sequent{\Gamma}{\cdot}{A} &
   \sequent{\Gamma, A}{\Delta}{C}}
\]

\subsection{Cut Free System}

\[
\infer[\one R]
{\seqnocut{\Gamma}{\cdot}{\one}}
{}
\tab
\infer[\one L]
{\seqnocut{\Gamma}{\Delta, \one}{C}}
{\seqnocut{\Gamma}{\Delta}{C}}
\]

\[
\infer[\with R]
{\seqnocut{\Gamma}{\Delta}{A \with B}}
{\seqnocut{\Gamma}{\Delta}{A} & \seqnocut{\Gamma}{\Delta}{B}}
\tab
\infer[\with L_1]
{\seqnocut{\Gamma}{\Delta, A \with B}{C}}
{\seqnocut{\Gamma}{\Delta, A}{C}}
\tab
\infer[\with L_2]
{\seqnocut{\Gamma}{\Delta, B \with B}{C}}
{\seqnocut{\Gamma}{\Delta, B}{C}}
\]

\[
\infer[\otimes R]
{\seqnocut{\Gamma}{\Delta, \Delta'}{A \otimes B}}
{\seqnocut{\Gamma}{\Delta}{A} & \seqnocut{\Gamma}{\Delta}{B}}
\tab
\infer[\otimes L]
{\seqnocut{\Gamma}{\Delta, A \otimes B}{C}}
{\seqnocut{\Gamma}{\Delta, A, B}{C}}
\]

\[
\infer[\lolli R]
{\seqnocut{\Gamma}{\Delta}{A \lolli B}}
{\seqnocut{\Gamma}{\Delta, A}{B}}
\tab
\infer[\lolli L]
{\seqnocut{\Gamma}{\Delta, \Delta', A \lolli B}{C}}
{\seqnocut{\Gamma}{\Delta}{A} &
   \seqnocut{\Gamma}{\Delta', B}{C}}
\]

\[
\infer[\forall R]
{\Psi ; \seqnocut{\Gamma}{\Delta}{\forall n:\tau. A}}
{\Psi, m:\tau ; \seqnocut{\Gamma}{\Delta}{A\{m/n\}}}
\tab
\infer[\forall L]
{\Psi ; \seqnocut{\Gamma}{\Delta, \forall n:\tau. A}{C}}
{\Psi \vdash M : \tau & \Psi ; \seqnocut{\Gamma}{\Delta, A\{M/n\}}{C}}
\]

\[
\infer[\exists R]
{\Psi \; \seqnocut{\Gamma}{\Delta}{\exists n: \tau. A}}
{\Psi \vdash M : \tau &
   \Psi \; \seqnocut{\Gamma}{\Delta}{A \{M/n\}}}
\tab
\infer[\exists L]
{\Psi ; \seqnocut{\Gamma}{\Delta, \exists n:\tau. A}{C}}
{\Psi, m:\tau ; \seqnocut{\Gamma}{\Delta, A\{m/n\}}{C}}
\]

\[
\infer[\bang R]
{\seqnocut{\Gamma}{\cdot}{\bang A}}
{\seqnocut{\Gamma}{\cdot}{A}}
\tab
\infer[\bang L]
{\seqnocut{\Gamma}{\Delta, \bang A}{C}}
{\seqnocut{\Gamma, A}{\Delta}{C}}
\tab
\infer[\m{copy}]
{\seqnocut{\Gamma, A}{\Delta}{C}}
{\seqnocut{\Gamma, A}{\Delta, A}{C}}
\]

\[
\infer[\m{def} \; R]
{\seqnocut{\Gamma}{\Delta}{\compr{A'}}}
{\seqnocut{\Gamma}{\Delta}{B\theta} &
 A \defeq B & A' \doteq A\theta}
\tab
\infer[\m{def} \; L]
{\seqnocut{\Gamma}{\Delta, \compr{A'}}{C}}
{
   \seqnocut{\Gamma}{\Delta, B\theta}{C} & A \defeq B & A' \doteq A\theta
}
\]

\subsection{Cut Elimination Theorem}

If $\seqnocut{\Gamma}{\Delta}{A}$ and $\seqnocut{\Gamma}{\Delta', A}{C}$ then $\seqnocut{\Gamma}{\Delta, \Delta'}{C}$

\section{Optimization Ideas}

\subsection{Data vs Control}

\begin{itemize}
   \item Discover facts that work like node fields and actually never go away (only their arguments change).
   \item Discover facts that drive the computation (usually are consumed and then go away).
\end{itemize}

\subsection{JIT Compilation}

Compile most used rules to assembly.

\subsection{Improve indexing}

Do just in time indexing by gathering statistics about indexing.

\subsection{Improve rule engine}

Indexing of the current set of facts needs to be vastly improved.

\subsection{Find consuming chain of linear facts}

Sometimes a linear fact $a$ derives a $b$ that derives a $c$, etc. Once $a$ is derived we know that a set of rules will be run in sequence. We need to prove that this will happen no matter what.

\subsection{Improved fact loading}

Allow compilation of facts to a separate file. Also, load facts faster.

\section{Low Level Dynamic Semantics}

Low level dynamic semantics handle:

\begin{itemize}
\item Rule priorities.
\item No guessing of values for variables.
\item Maximality for definitions.
\end{itemize}

For the low level semantics, we consider that $\Theta$ (rules with priority)
is an ordered context of rules.

\newcommand{\applyl}[6]{\m{apply1} \; #1 ; #2 ; #3 \rightarrow #4 ; #5 ; #6}

\[
\infer[\m{rule \; app \; priority}]
{\Psi ; R, \Theta; \Phi; \Gamma; \Delta \hookrightarrow \Gamma'; \Delta' ; \Xi'}
{\applyl{\Psi}{\Gamma}{\Delta ; [R] ; (\m{rule}; \Theta; \Phi ; \Delta)}{\Gamma'}{\Delta'}{\Xi'}}
\]

\[
\infer[\m{rule \; app \; no \; priority}]
{\Psi ; \cdot; R, \Phi ; \Gamma ; \Delta \hookrightarrow \Gamma'; \Delta' ; \Xi'}
{\applyl{\Psi}{\Gamma}{\Delta ; [R] ; (\m{rule} ; \Theta; \Phi ; \Delta)}{\Gamma'}{\Delta'}{\Xi'}}
\]

Note that in the following rule, we do not guess the terms for the variables. Instead, we will try to match the variables against the available facts.

\[
\infer[\m{\forall L}]
{\applyl{\Psi}{\Gamma}{\Delta ; [\forall X : \tau. A] ; C}{\Gamma'}{\Delta'}{\Xi}}
{\applyl{\Psi}{\Gamma}{\Delta ; [A\{\m{var}(X)/X\}]; C}{\Gamma'}{\Delta'}{\Xi}}
\]

Once we get to the implication, we pick both body and head with a rule continuations. The continuation context will have the different facts that may be used to apply the rule. The body $A$ is an ordered context.

\[
\infer[\m{\lolli L}]
{\applyl{\Psi}{\Gamma}{\Delta ; [A \lolli B] ; C}{\Gamma'}{\Delta'}{\Xi'}}
{\m{matchbody} \; \Psi;\Gamma; \Delta ; \cdot ; A ; \cdot ; B ; (\cdot, C) \rightarrow \Gamma' ; \Delta' ; \Xi'}
\]

\subsection{Match Body}

This judgment goes through the ordered body context and matches the facts gainst the linear or persistent context. Constraints are put into the context at the right. Once we match everything correctly, we go through the constraint context (note: not an ordered context) and validate each constraint. If a constraint fails or a match fails, we pick the next continuation (body + facts).

For $\exists$, we do the same thing as we did above for $\forall$.

\[
\infer[\m{matchbody \; exists}]
{\m{matchbody} \; \Psi ; \Gamma ; \Delta ; \Xi ; \exists X. A', A ; B ; H ; C \rightarrow \Gamma' ; \Delta' ; \Xi'}
{\m{matchbody} \; \Psi ; \Gamma ; \Delta ; \Xi ; [\m{var}(X)/X]A', [\m{var}(X)/X]A ; [\m{var}(X)/X]B; [\m{var}(X)/X]H ; C \rightarrow \Gamma' ; \Delta' ; \Xi'}
\]


If we get $1$, we just skip it.

\[
\infer[\m{matchbody \; one}]
{\m{matchbody} \; \Psi;\Gamma;\Delta ; \Xi ; 1, A ; B ; H ; C \rightarrow \Gamma' ; \Delta' ; \Xi'}
{\m{matchbody} \; \Psi;\Gamma;\Delta ; \Xi ; A ; B ; H ; C \rightarrow \Gamma' ; \Delta' ; \Xi'}
\]

For $\otimes$ we simply deconstruct the connective and keep both elements in the ordered context.

\[
\infer[\m{matchbody \; split}]
{\m{matchbody} \; \Psi;\Gamma;\Delta; \Xi ; A_1 \otimes A_2, A ; B ; H ; C \rightarrow \Gamma' ; \Delta' ; \Xi'}
{\m{matchbody} \; \Psi;\Gamma;\Delta; \Xi ; A_1, A_2, A ; B ; H ; C \rightarrow \Gamma' ; \Delta' ; \Xi'}
\]

This is the constraint case. We simply move the constraint to the constraint context.

\[
\infer[\m{matchbody \; constraint}]
{\m{matchbody} \; \Psi;\Gamma;\Delta; \Xi ; \bang\constraint{e}, A; B ; H ; C \rightarrow \Gamma' ; \Delta' ; \Xi'}
{\m{matchbody} \; \Psi ; \Gamma; \Delta; \Xi ; A ; \bang\constraint{e}, B ; H ; C \rightarrow \Gamma' ; \Delta' ; \Xi'}
\]

Finally, the linear case! Here we have two cases, either we have facts in the linear context of this type or we don't.

\[
\infer[\m{matchbody \; linear}]
{\m{matchbody} \; \Psi;\Gamma;\Delta, \Delta_f; \Xi ; \fact{name}{e_1}{e_2, ..., e_n}, A; B; H; (C_1, C_2) \rightarrow \Gamma' ; \Delta'; \Xi'}
{\begin{array}{c}
   \Delta_f = \m{list} \; [ \fact{name}{v_1}{v_2, ..., v_n} | Xs] \\
    NC = (\m{body}; \fact{name}{e_1}{e_2, ..., e_n} ; Xs ; \Delta ; \Xi ; A ; B ; H; C_1) \\
    \Delta_1 = \Delta, \Delta_f - \{\fact{name}{v_1}{v_2, ..., v_n}\} \\
   \m{matchfact} \; \Psi;\Gamma; \Delta_1; \fact{name}{v_1}{v_2, ..., v_n}, \Xi ; [v_1, ..., v_n] ; [e_1, ..., e_n]; A ; B ; H; (NC, C_2) \rightarrow \Gamma' ; \Delta'; \Xi' \\
 \end{array}
}
\]

\[
\infer[\m{matchbody \; linear \; empty}]
{\m{matchbody} \; \Psi;\Gamma;\Delta,\Delta_f; \Xi ; \fact{name}{e_1}{e_2, ..., e_n}, A ; B; H; C \rightarrow \Gamma';\Delta';\Xi'}
{\begin{array}{c}
   \Delta_f = [] \\
   \m{cont} \; \Psi; \Gamma ; C \rightarrow \Gamma';\Delta';\Xi'
  \end{array}
}
\]

Persistent facts are very similar, except we don't mess with the linear context.

\[
\infer[\m{matchbody \; persistent}]
{\m{matchbody} \; \Psi;\Gamma, \Gamma_f;\Delta; \Xi ; \bang\fact{name}{e_1}{e_2, ..., e_n}, A; B; H; (C_1, C_2) \rightarrow \Gamma' ; \Delta'; \Xi'}
{\begin{array}{c}
   \Gamma_f = \m{list} \; [\bang\fact{name}{v_1}{v_2, ..., v_n} | Xs] \\
    NC = (\m{body}; \bang\fact{name}{e_1}{e_2, ..., e_n} ; Xs ; \Delta ; \Xi ; A ; B ; H; C_1) \\
   \m{matchfact} \; \Psi;\Gamma, \Gamma_f; \Delta; \Xi ; [v_1, ..., v_n] ; [e_1, ..., e_n]; A ; B ; H; (NC, C_2) \rightarrow \Gamma' ; \Delta'; \Xi' \\
 \end{array}
}
\]

\[
\infer[\m{matchbody \; persistent \; empty}]
{\m{matchbody} \; \Psi;\Gamma, \Gamma_f;\Delta; \Xi ; \bang\fact{name}{e_1}{e_2, ..., e_n}, A ; B; H; C \rightarrow \Gamma';\Delta';\Xi'}
{\begin{array}{c}
   \Gamma_f = [] \\
   \m{cont} \; \Psi; \Gamma ; C \rightarrow \Gamma';\Delta';\Xi'
  \end{array}
}
\]

Now we get to the case where we have no more facts to process. We use $\m{matchconstr}$ to match the required constraints. Note that all constraints will be instantiated at this point, so they can be evaluated.

\[
\infer[\m{matchbody \; end}]
{\m{matchbody} \; \Psi; \Gamma ; \Delta; \Xi; \cdot ; B ; H; C \rightarrow \Gamma'; \Delta'; \Xi'}
{\m{matchconstr} \; \Psi; \Gamma; \Delta; \Xi; B; H; C \rightarrow \Gamma'; \Delta'; \Xi'}
\]

\subsubsection{Match Facts}

The following judgments match the fact from the context with the fact from the rule.

\[
\infer[\m{matchfact \; var}]
{\m{matchfact} \; \Psi;\Gamma;\Delta;\Xi; [v | v_s] ; [\m{var}(X) \| e_s]; A; B; H; C \rightarrow \Gamma'; \Delta'; \Xi'}
{\m{matchfact} \; \Psi;\Gamma;\Delta;\Xi; v_s; [v/\m{var}(X)]e_s; [v/\m{var}(X)]A; [v/\m{var}(X)]B; [v/\m{var}(X)]H; C \rightarrow \Gamma'; \Delta'; \Xi'}
\]

\[
\infer[\m{matchfact \; equal}]
{\m{matchfact} \; \Psi;\Gamma;\Delta;\Xi; [v_1 | v_s] ; [v_2 | e_s]; A; B; H; C \rightarrow \Gamma'; \Delta'; \Xi'}
{\m{matchfact} \; \Psi;\Gamma;\Delta;\Xi; v_s; e_s; A; B; H; C \rightarrow \Gamma'; \Delta'; \Xi' & \equal{v_1}{v_2}}
\]

If they are not equal, we fail and grab the next continuation:

\[
\infer[\m{matchfact \; not \; equal}]
{\m{matchfact} \; \Psi;\Gamma;\Delta;\Xi; [v_1 | v_s] ; [v_2 | e_s]; A; B; H; C \rightarrow \Gamma'; \Delta'; \Xi'}
{\m{cont} \; \Psi ; \Gamma ; C \rightarrow \Gamma'; \Delta'; \Xi' & v_1 \neq v_2}
\]

\[
\infer[\m{matchfact \; done}]
{\m{matchfact} \; \Psi;\Gamma; \Delta; \Xi ; [] ; []; A ; B ; H; C \rightarrow \Gamma' ; \Delta'; \Xi'}
{\m{matchbody} \; \Psi;\Gamma;\Delta;\Xi; A; B; H; C \rightarrow \Gamma'; \Delta'; \Xi'}
\]

\subsubsection{Match Constraints}

If a constraint succeeds, we keep going on.

\[
\infer[\m{matchconstr \; true}]
{\m{matchconstr} \; \Psi;\Gamma;\Delta;\Xi; \bang\constraint{e}, B ; H; C \rightarrow \Gamma'; \Delta'; \Xi'}
{\eval{e}{\m{bool}(\m{true})} & \m{matchconstr} \; \Psi;\Gamma;\Delta;\Xi; B; H; C \rightarrow \Gamma'; \Delta'; \Xi'}
\]

If not, we get a continuation to try another fact.

\[
\infer[\m{matchconstr \; false}]
{\m{matchconstr} \; \Psi;\Gamma;\Delta;\Xi; \bang\constraint{e}, B ; H; C \rightarrow \Gamma'; \Delta'; \Xi'}
{\eval{e}{\m{bool}(\m{false})} & \m{cont} \; \Psi;\Gamma; C \rightarrow \Gamma'; \Delta'; \Xi'}
\]

Once all constraints are validated, we have succeeded in matching the body rule, so we can start deriving new facts.
Note that we get rid of all continuations.

\[
\infer[\m{matchconstr \; end}]
{\m{matchconstr} \; \Psi;\Gamma;\Delta;\Xi; \cdot ; H ; (C_1, (\m{rule}; ...)) \rightarrow \Gamma';\Delta';\Xi'}
{\m{derive1} \; \Psi;\Gamma;\Delta;\Xi; \cdot; \cdot; H ; \cdot \rightarrow \Gamma';\Delta';\Xi'}
\]

The derive continuation is kept however. This way we can return back to the original derivation.

\[
\infer[\m{matchconstr \; end}]
{\m{matchconstr} \; \Psi;\Gamma;\Delta;\Xi; \cdot ; H ; (C_1, (\m{derive}; \Delta''; \Xi''; \Gamma_1 ; \Delta_1 ; K ; \Omega)) \rightarrow \Gamma';\Delta';\Xi'}
{\m{derive1} \; \Psi;\Gamma;\Delta;\Xi; \cdot; \cdot; H ; (\m{derive}; \Delta'' ; \Xi''; \Gamma_1; \Delta_1 ; K; \Omega) \rightarrow \Gamma';\Delta';\Xi'}
\]

\subsubsection{Continuation}

If we have no more fact continuations, we need to get the rule continuation to try another rule.

\[
\infer[\m{cont \; rule}]
{\m{cont} \; \Psi ; \Gamma ; (\cdot , (\m{rule} ; \Theta ; \Phi ; \Delta)) \rightarrow \Gamma'; \Delta'; \Xi'}
{\Psi ; \Theta; \Phi; \Gamma ; \Delta \hookrightarrow \Gamma'; \Delta' ; \Xi'}
\]

... If there is a derive continuation, it means that an aggregate or continuation has failed.

\[
\infer[\m{cont \; comp}]
{\m{cont} \; \Psi ; \Gamma ; (\cdot , (\m{derive}; \Delta ; \Xi; \Gamma_1; \Delta_1; \comprehension{A}; \Omega)) \rightarrow \Gamma'; \Delta'; \Xi'}
{\m{derive1} \; \Psi ; \Gamma ; \Delta ; \Xi ; \Gamma_1 ; \Delta_1 ; \Omega ; \cdot \rightarrow \Gamma' ; \Delta' ; \Xi'}
\]

\[
\infer[\m{cont \; aggregate}]
{\m{cont} \; \Psi ; \Gamma ; (\cdot , (\m{derive}; \Delta ; \Xi; \Gamma_1; \Delta_1; \aggdef{Op}{V}{(x. A(x))}{(y. B(y))}; \Omega)) \rightarrow \Gamma'; \Delta'; \Xi'}
{\m{derive1} \; \Psi ; \Gamma ; \Delta ; \Xi ; \Gamma_1 ; \Delta_1 ; B(V), \Omega; \cdot \rightarrow \Gamma' ; \Delta' ; \Xi'}
\]

If we have a fact continuation but no more facts for that continuation, we fail and continue:

\[
\infer[\m{cont \; body \; fail}]
{\m{cont} \; \Psi ; \Gamma ; ((\m{body} ; \fact{name}{e_1}{e_2, ..., e_n} ; []; \Delta ; \Xi ; A ; B; H; C), C_2) \rightarrow \Gamma'; \Delta'; \Xi'}
{
   \m{cont} \; \Psi ; \Gamma ; (C, C_2) \rightarrow \Gamma'; \Delta'; \Xi'
}
\]

If we have a fact continuation and also more facts, restore the continuation and continue:

\[
\infer[\m{cont \; body \; ok}]
{\m{cont} \; \Psi ; \Gamma ; ((\m{body} ; \fact{name}{e_1}{e_2, ..., e_n} ; [\fact{name}{v_1}{v_2, ..., v_n} | Xs]; \Delta ; \Xi ; A ; B ; H; C_1), C_2) \rightarrow \Gamma'; \Delta'; \Xi'}
{
   \begin{array}{c}
   \Delta_1 = \Delta - {\fact{name}{v_1}{v_2, ..., v_n}}\\
   NC = (\m{body}; \fact{name}{e_1}{e_2, ..., e_n}; \Delta; A; B; H; C_1) \\
   \m{matchfact} \; \Psi ; \Gamma; \Delta_1 ; \fact{name}{v_1}{v_2, ..., v_n}, \Xi ; [v_1, ..., v_n]; [e_1, ..., e_n]; A; B; H; (NC, C_2) \rightarrow \Gamma' ; \Delta'; \Xi'\\
   \end{array}
}
\]

\subsubsection{Derive}

\[
\infer[\m{derive \; \otimes}]
{\m{derive1} \; \Psi; \Gamma ; \Delta ; \Xi ; \Gamma_1; \Delta_1 ; A \otimes B, \Omega ; C \rightarrow \Gamma'; \Delta'; \Xi'}
{\m{derive1} \; \Psi; \Gamma ; \Delta ; \Xi ; \Gamma_1; \Delta_1 ; A, B, \Omega; C \rightarrow \Gamma'; \Delta'; \Xi'}
\]

\[
\infer[\m{derive \; exists}]
{\m{derive1} \; \Psi ; \Gamma ; \Delta ; \Xi; \Gamma_1 ; \Delta_1 ; \exists X : \m{addr}. A, \Omega ; C \rightarrow \Gamma'; \Delta' ; \Xi'}
{\m{derive1} \; \Psi ; \Gamma ; \Delta ; \Xi; \Gamma_1 ; \Delta_1 ; [x/X]A, \Omega ; C \rightarrow \Gamma'; \Delta'; \Xi'
   & x = \m{new} \; \m{addr}(A)}
\]

\[
\infer[\m{derive \; 1}]
{\m{derive1} \; \Psi ; \Gamma ; \Delta ; \Xi; \Gamma_1 ; \Delta_1 ; 1, \Omega ; C \rightarrow \Gamma'; \Delta' ; \Xi'}
{\m{derive1} \; \Psi ; \Gamma ; \Delta ; \Xi; \Gamma_1 ; \Delta_1 ; \Omega ; C \rightarrow \Gamma'; \Delta' ; \Xi'}
\]


\[
\infer[\m{derive \; fact}]
{\m{derive1} \; \Psi ; \Gamma ; \Delta ; \Xi ; \Gamma_1; \Delta_1 ; \fact{name}{e_1}{e_2, ..., e_n}, \Omega ; C \rightarrow \Gamma'; \Delta'; \Xi'}
{\begin{array}{ccc}
   \eval{e_1}{v_1} & ... & \eval{e_n}{v_n} \\
   \multicolumn{3}{c}{\m{derive1} \; \Psi ; \Gamma ; \Delta ; \Xi ; \Gamma_1 ; \Delta_1, \fact{name}{v_1}{v_2, ..., v_n} ; \Omega ; C \rightarrow \Gamma'; \Delta' ; \Xi'} \\
   \end{array}
}
\]

\[
\infer[\m{derive \; \bang fact}]
{\m{derive1} \; \Psi ; \Gamma ; \Delta ; \Xi ; \Gamma_1 ; \Delta_1 ; \bang \fact{name}{e_1}{e_2, ..., e_n}, \Omega ; C \rightarrow \Gamma'; \Delta' \Xi'}
{\begin{array}{ccc}
   \eval{e_1}{v_1} & ... & \eval{e_n}{v_n} \\
   \multicolumn{3}{c}{\m{derive1} \; \Psi ; \Gamma ; \Delta ; \Xi; \Gamma_1, \bang\fact{name}{v_1}{v_2, ..., v_n} ; \Delta_1 ; \Omega ; C \rightarrow \Gamma'; \Delta'; \Xi'} \\
   \end{array}
}
\]

For the comprehension, we define a new continuation for the current state of derivation and call $\m{apply}$ in order to attempt applying the comprehension. Comprehension fails in one of the $\m{cont}$ cases. It succeeds when derive reaches the end and a continuation is in place.


\[
\infer[\m{derive \; comprehension}]
{\m{derive1} \; \Psi ; \Gamma; \Delta;\Xi;\Gamma_1;\Delta_1; \comprehension{A}, \Omega; \cdot \rightarrow \Gamma' ;\Delta'; \Xi'}
{\applyl{\Psi}{\Gamma}{\Delta ; [A] ; (\m{derive1}; \Delta ; \Xi; \Gamma_1; \Delta_1; \comprehension{A} ; \Omega)}{\Gamma'}{\Delta'}{\Xi'}}
\]

We first change the aggregate definition. Note that this only happens at this derivation level (no continuation possible).

\[
\infer[\m{derive \; aggregate}]
{\m{derive1} \; \Psi; \Gamma; \Delta; \Xi; \Gamma_1; \Delta_1; \aggregate{Op}{X}{A}{B}, \Omega; \cdot \rightarrow \Gamma' ; \Delta'; \Xi'}
{\aggregatestart{Op}{V} & \m{derive1} \; \Psi;\Gamma;\Delta;\Xi;\Gamma_1;\Delta_1; \aggdef{Op}{V}{(x. A(x))}{(y. B(y))}, \Omega; \cdot \rightarrow \Gamma'; \Delta'; \Xi'}
\]

When unfolding the aggregate and if there is an aggregate continuation (aggregate has already been applied multiple times), we need to change the definition of the aggregate inside the continuation. Note that the derivation context ($\Omega$) must only contain the aggregate.

\fontsize{8}{9.5}\selectfont
\[
\infer[\m{derive \; aggregate \; unfold}]
{\m{derive1} \; \Psi; \Gamma; \Delta; \Xi; \Gamma_1; \Delta_1; \aggdef{Op}{V'}{(x. A(x))}{(y. B(y))} ; (\m{derive} ; \Delta'' ; \Xi''; \Gamma'_1; \Delta'_1; \aggdef{Op}{V}{(x. A(x))}{(y. B(y))} ; \Omega) \rightarrow \Gamma'; \Delta'; \Xi'}
{\begin{array}{c}
   \applyl{\Psi}{\Gamma}{\Delta ; [\forall X'. A(X') \lolli \aggdef{Op}{E}{(x. A(x))}{(y. B(y))}] ; (\m{derive}; \Delta ; \Xi, \Xi''; \Gamma_1, \Gamma'_1; \Delta_1, \Delta'_1; \aggdef{Op}{V'}{(x. A(x))}{(y. B(y))} ; \Omega)}{\Gamma'}{\Delta'}{\Xi'}\\
   \aggregateop{Op}{V'}{X'}{E} \\
      \end{array}
}
\]

\fontsize{10}{9.5}\selectfont
Otherwise, if we get an aggregate without a continuation:

\fontsize{8}{9.5}\selectfont
\[
\infer[\m{derive \; aggregate \; unfold}]
{\m{derive1} \; \Psi; \Gamma; \Delta; \Xi; \Gamma_1; \Delta_1; \aggdef{Op}{V}{(x. A(x))}{(y. B(y))}, \Omega ; \cdot \rightarrow \Gamma'; \Delta'; \Xi'}
{\begin{array}{c}
   \applyl{\Psi}{\Gamma}{\Delta ; [\forall X'. A(X') \lolli \aggdef{Op}{E}{(x. A(x))}{(y. B(y))}] ; (\m{derive}; \Delta ; \Xi; \Gamma_1; \Delta_1; \aggdef{Op}{V}{(x. A(x))}{(y. B(y))} ; \Omega)}{\Gamma'}{\Delta'}{\Xi'}\\
   \aggregateop{Op}{V}{X'}{E} \\
      \end{array}
}
\]

\fontsize{10}{9.5}\selectfont

If $\m{derive}$ ends and there is a continuation, it means that either the aggregate or comprehension can be reused again.

\[
\infer[\m{derive \; comprehension \; end}]
{\m{derive1} \; \Psi ; \Gamma ; \Delta; \Xi; \Gamma_1; \Delta_1 ; \cdot ; (\m{derive}; \Delta'' ; \Xi''; \Gamma'_1; \Delta'_1; \comprehension{A} ; \Omega) \rightarrow \Gamma' ; \Delta' ; \Xi'}
{
   \m{derive1} \; \Psi ; \Gamma ; \Delta ; \Xi, \Xi''; \Gamma_1, \Gamma'_1; \Delta_1, \Delta'_1; \comprehension{A}, \Omega; \cdot \rightarrow \Gamma'; \Delta'; \Xi'}
\]

This is the axiom that wraps everything up. If no rule is applicable in the system, then there is no valid proof derivation.

\[
\infer[\m{derive \; end}]
{\m{derive1} \; \Psi ; \Gamma ; \Delta; \Xi; \Gamma_1; \Delta_1; \cdot ; \cdot \rightarrow \Gamma_1 ; \Delta_1 ; \Xi}
{}
\]

\section{Simplified Systems}

\newcommand{\mz}{\m{m}_0 \;}
\newcommand{\mo}{\m{m}_1 \;}
\newcommand{\dz}{\m{d}_0 \;}
\newcommand{\done}{\m{d}_1 \;}
\newcommand{\az}{\m{a}_0 \;}
\newcommand{\ao}{\m{a}_1 \;}
\newcommand{\doz}{\m{do}_0 \;}
\newcommand{\doo}{\m{do}_1 \;}
\newcommand{\cont}{\m{cont} \;}
\newcommand{\contc}{\m{contc} \;}
\newcommand{\dc}{\m{dc} \;}

\subsection{High Level System}

\subsubsection{Match}

\[
\infer[1]
{\mz \cdot ; 1 \rightarrow \cdot}
{}
\]

\[
\infer[p]
{\mz p ; p \rightarrow p}
{}
\]

\[
\infer[\otimes]
{\mz \Delta_1, \Delta_2 ; A \otimes B \rightarrow \Xi_1, \Xi_2}
{\mz \Delta_1 ; A \rightarrow \Xi_1 & \mz \Delta_2 ; B \rightarrow \Xi_2}
\]

\subsubsection{Derive}

\[
\infer[p]
{\dz \Delta ; \Xi ; \Delta_1 ; p, \Omega \rightarrow \Xi' ; \Delta'}
{\dz \Delta ; \Xi ; p, \Delta_1 ; \Omega \rightarrow \Xi' ; \Delta'}
\tab
\infer[1]
{\dz \Delta; \Xi; \Delta_1; 1, \Omega \rightarrow \Xi';\Delta'}
{\dz \Delta; \Xi; \Delta_1; \Omega \rightarrow \Xi';\Delta'}
\]


\[
\infer[\otimes]
{\dz \Delta;\Xi;\Delta_1;A \otimes B, \Omega \rightarrow \Xi'; \Delta'}
{\dz \Delta;\Xi;\Delta_1;A, B, \Omega \rightarrow \Xi';\Delta'}
\tab
\]

\[
\infer[\with L]
{\dz \Delta; \Xi; \Delta_1; A \with B, \Omega \rightarrow \Xi';\Delta'}
{\dz \Delta; \Xi; \Delta_1; A, \Omega \rightarrow \Xi';\Delta'}
\tab
\infer[\with R]
{\dz \Delta; \Xi; \Delta_1; A \with B, \Omega \rightarrow \Xi';\Delta'}
{\dz \Delta; \Xi; \Delta_1; B, \Omega \rightarrow \Xi';\Delta'}
\]

\[
\infer[\m{unfold \; comp}]
{\dz \Delta ; \Xi; \Delta_1; \m{comp} A \lolli B, \Omega \rightarrow \Xi';\Delta'}
{\dz \Delta; \Xi; \Delta_1; 1 \with (A \lolli B \otimes \m{comp} A \lolli B), \Omega \rightarrow \Xi';\Delta'}
\]

\[
\infer[\lolli \; \m{comp}]
{\dz \Delta_a, \Delta_b; \Xi; \Delta_1; A \lolli B, \Omega \rightarrow \Xi';\Delta'}
{\mz \Delta_a; A \rightarrow \Delta_a & \dz \Delta_b ; \Xi; \Delta_a; \Delta_1; B, \Omega \rightarrow \Xi'; \Delta'}
\]

\[
\infer[\m{end}]
{\dz \Delta; \Xi'; \Delta'; \cdot \rightarrow \Xi';\Delta'}
{}
\]

\subsubsection{Apply}

\[
\infer[\m{apply \; rule}]
{\az \Delta, \Delta''; A \lolli B \rightarrow \Xi'; \Delta'}
{\mz \Delta; A \rightarrow \Delta & \dz \Delta''; \Delta; \cdot ; B \rightarrow \Xi'; \Delta'}
\]

\[
\infer[\m{end}]
{\doz \Delta; R, \Phi \rightarrow \Xi';\Delta'}
{\doz \Delta; R \rightarrow \Xi';\Delta'}
\]

\subsection{Low Level System}

\subsubsection{Match}


\[
\infer[ok]
{\mo \Delta, p ; \Xi; p, \Omega; H; C \rightarrow \Xi'; \Delta'}
{\mo \Delta; \Xi, p; \Omega; H; C \rightarrow \Xi'; \Delta'}
\tab
\infer[fail]
{\mo \Delta; \Xi; p, \Omega; H; C \rightarrow \Xi'; \Delta'}
{p \notin \Delta & \cont C ; H; \Xi'; \Delta'}
\]

\[
\infer[\tensor]
{\mo \Delta; \Xi; A \otimes B, \Omega ; H ; C \rightarrow \Xi'; \Delta'}
{\mo \Delta; \Xi; A, B, \Omega; H; C \rightarrow \Xi';\Delta'}
\]

\[
\infer[\m{rule} \; \m{cont}]
{\mo \Delta; \Xi; \cdot ; H; (\Phi; \Delta'') \rightarrow \Xi'; \Delta'}
{\done \Delta; \Xi; \cdot ; H; \cdot \rightarrow \Xi'; \Delta'}
\]

\subsubsection{Derive}

\[
\infer[p]
{\done \Delta; \Xi; \Delta_1; p, \Omega; C \rightarrow \Xi'; \Delta'}
{\done \Delta; \Xi; p, \Delta_1; \Omega; C \rightarrow \Xi'; \Delta'}
\tab
\infer[1]
{\done \Delta; \Xi; \Delta_1; 1, \Omega; C \rightarrow \Xi';\Delta'}
{\done \Delta; \Xi; \Delta_1; \Omega; C \rightarrow \Xi'; \Delta'}
\]

\[
\infer[\otimes]
{\done \Delta; \Xi; \Delta_1; A \otimes B, \Omega; C \rightarrow \Xi'; \Delta'}
{\done \Delta; \Xi; \Delta_1; A, B, \Omega; C \rightarrow \Xi';\Delta'}
\]

\[
\infer[\m{comp}]
{\done \Delta; \Xi; \Delta_1; \m{comp} \; A \lolli B, \Omega; \cdot \rightarrow \Xi'; \Delta'}
{\ao \Delta; A \lolli B; (\done \Delta; \Xi; \Delta_1; \m{comp} \; A \lolli B, \Omega; \cdot) \rightarrow \Xi'; \Delta'}
\]

\[
\infer[\m{comp \; derivation}]
{\mo \Delta; \Xi; \cdot; H; (\done \Delta''; \Xi''; \Delta_1; \m{comp} \; A \lolli B, \Omega; \cdot) \rightarrow \Xi'; \Delta'}
{\done \Delta; \Xi; \cdot ; H; (\done \Delta''; \Xi''; \Delta_1; \m{comp} \; A \lolli B, \Omega; \cdot) \rightarrow \Xi'; \Delta'}
\]

\[
\infer[\m{end}]
{\done \Delta; \Xi; \Delta_1; \cdot; \cdot \rightarrow \Xi; \Delta_1}
{}
\]

\[
\infer[\m{next \; comp}]
{\done \Delta; \Xi; \Delta_1; \cdot; (\done \Delta''; \Xi''; \Delta''_1; \m{comp} \; A \lolli B, \Omega) \rightarrow \Xi'; \Delta'}
{\done \Delta; \Xi, \Xi''; \Delta_1, \Delta''_1; \m{comp} \; A \lolli B, \Omega; \cdot \rightarrow \Xi'; \Delta'}
\]

\subsubsection{Continuations}

\[
\infer[\m{rule \; fail}]
{\cont (\Phi; \Delta); \Xi'; \Delta'}
{\doo \Delta; \Phi \rightarrow \Xi'; \Delta'}
\]

\[
\infer[\m{comp \; done}]
{\cont (\done \Delta''; \Xi''; \Delta_1; \m{comp} \; A \lolli B, \Omega); \Xi'; \Delta'}
{\done \Delta; \Xi''; \Delta_1; \Omega; \cdot \rightarrow \Xi'; \Delta'}
\]

\subsubsection{Apply}

\[
\infer[\m{apply \; rule}]
{\ao \Delta; A \lolli B; C \rightarrow \Xi'; \Delta'}
{\mo \Delta; \cdot; A; B; C \rightarrow \Xi'; \Delta'}
\]

\[
\infer[\m{pick \; rule}]
{\doo \Delta; R, \Phi \rightarrow \Xi'; \Delta'}
{\ao \Delta; R; (\Phi; \Delta) \rightarrow \Xi';\Delta'}
\]

\subsection{Low level comprehension match succeeds or fails}

If $\mo \Delta'', \Delta_1, ..., \Delta_n; \Xi; \Omega; H; (\done \Delta'''; \Xi''; \Delta_1; \m{comp} \; A \lolli B, \Omega') \rightarrow \Xi'; \Delta'$ then either:

\begin{itemize}
\item $\cont (\done \Delta'''; \Xi''; \Delta_1; \m{comp} \; A \lolli B, \Omega'); \Xi'; \Delta'$ or
\item $\mo \Delta''; \Xi, \Delta_1, ..., \Delta_n' \cdot ; H ; (\done ...) \rightarrow \Xi'; \Delta'$ and $\Omega = \Omega_1, ..., \Omega_n$ where $\mz \Delta_1; \Omega_1 \rightarrow \Delta_1$, ..., $\mz \Delta_n ; \Omega_n \rightarrow \Delta_n$ and $\Delta_1, ..., \Delta_n$ is not empty.
\end{itemize}

It's trivial by induction on the assumption, except the case $p, \Omega$ and $A \otimes B, \Omega$.

\subsection{Low level comprehension gives one match}

If $\mo \Delta'', \Xi''; \cdot; A ; H; (\done \Delta'''; \Xi; \Delta_1; \m{comp} \; A \lolli B, \Omega') \rightarrow \Xi'; \Delta'$ then either

\begin{itemize}
\item $\cont (\done \Delta'''; \Xi; \Delta_1; \m{comp} \; A \lolli B, \Omega'); \Xi'; \Delta'$ or
\item $\mo \Delta'' ; \Xi''; \cdot; H; (\done \Delta'''; \Xi; \Delta_1; \m{comp} \; A \lolli B, \Omega') \rightarrow \Xi'; \Delta'$ and $\mz \Xi''; A \rightarrow \Xi''$, where $\Xi''$ is not empty
\end{itemize}

This follows trivially from the previous theorem.

\subsection{Comprehension head is another derivation theorem}

If $\done \Delta; \Xi; \Delta_1; \Omega'; (\done \Delta''; \Xi''; \Delta'_1; \m{comp} \; A \lolli B, \Omega) \rightarrow \Xi'; \Delta'$ \\ then \\ $\done \Delta; \Xi, \Xi''; \Delta_1, \Delta'_1; \Omega', \m{comp} \; A \lolli B, \Omega; \cdot \rightarrow \Xi'; \Delta'$.

\begin{itemize}
\item $p$

$\done \Delta; \Xi; \Delta_1; p, \Omega''; (\done ...) \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
$\Omega' = p, \Omega''$ \hfill (2) from (1) \\
$\done \Delta; \Xi; p, \Delta_1; \Omega''; (\done ...) \rightarrow \Xi'; \Delta'$ \hfill (3) inversion of (1) \\
$\done \Delta; \Xi, \Xi''; p, \Delta_1, \Delta'_1; \Omega'', \m{comp} \; A \lolli B, \Omega; \cdot \rightarrow \Xi'; \Delta'$ \hfill (4) i.h. on (3) \\
$\done \Delta; \Xi, \Xi''; \Delta_1, \Delta'_1; p, \Omega'', \m{comp} \; A \lolli B, \Omega; \cdot \rightarrow \Xi'; \Delta'$ \hfill (5) apply rule on (4) \\

\item $A \otimes B$

$\done \Delta; \Xi, \Xi''; \Delta_1, \Delta'_1; A, B, \Omega''; \m{comp} \; A \lolli B, \Omega; \cdot \rightarrow \Xi'; \Delta'$ \hfill (1) by i.h. \\
$\done \Delta; \Xi, \Xi''; \Delta_1, \Delta'_1; A \otimes B, \Omega''; \m{comp} \; A \lolli B, \Omega; \cdot \rightarrow \Xi'; \Delta'$ \hfill (2) rule application on (1) \\

\item $\cdot$

$\done \Delta; \Xi; \Delta_1; \cdot; (\done \Delta''; \Xi''; \Delta'_1; \m{comp} \; A \lolli B, \Omega) \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
$\done \Delta; \Xi, \Xi''; \Delta_1, \Delta'_1; \m{comp} \; A \lolli B, \Omega; \cdot \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1) \\

\end{itemize}

\subsection{Low level matching gives high level matching theorem}

If \\
$\mo \Delta, \Delta_1, ..., \Delta_n; \Xi; A_1, ..., A_n; H; \cdot \rightarrow \Xi'; \Delta'$ \\
then \\
$\mz \Delta_1; A_1 \rightarrow \Delta_1$ through $\mz \Delta_n; A_n \rightarrow \Delta_n$ and \\
$\mo \Delta; \Xi, \Delta_1, ..., \Delta_n; \cdot; H; \cdot \rightarrow \Xi'; \Delta'$ and \\
$\Delta_1, ..., \Delta_n$ is not empty if $A_1, ..., A_n$ is not $\cdot$.

Induction on $\Omega = A_1, ..., A_n$.

\begin{itemize}
\item $p, \Omega$ and $p \notin \Delta$

Not applicable.

\item $p, \Omega$

$\mo \Delta, \Delta_1, ..., \Delta_n, p; \Xi; p, A_1, ..., A_n; H; \cdot \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
$\mo \Delta, \Delta_1, ..., \Delta_n; \Xi, p; A_1, ..., A_n; H; \cdot \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
$\mz \Delta_1 ; A_1 \rightarrow \Delta_1$ ... $\mz \Delta_n ; A_n \rightarrow \Delta_n$ \hfill (3) induction on (2) \\
$\mo \Delta; \Xi, p, \Delta_1, ..., \Delta_n; \cdot ; H ; \cdot \rightarrow \Xi'; \Delta'$ \hfill (4) induction on (2) \\
$\mz p; p \rightarrow p$ \hfill (5) axiom \\
$p, \Delta_1, ..., \Delta_n$ is not empty\\

\item $A \otimes B, \Omega$

$\mo \Delta, \Delta_1, ..., \Delta_n; \Xi; A \otimes B, A_1, ..., A_{n-2}; H; \cdot \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
$\mo \Delta, \Delta_1, ..., \Delta_n; \Xi; A, B, A_1, ..., A_{n-2}; H; \cdot \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
$\mo \Delta; \Xi, \Delta_1, ..., \Delta_n; \cdot ; H; \cdot \rightarrow \Xi'; \Delta'$ \hfill (3) induction on (2) \\
$\mz \Delta_1 ; A \rightarrow \Delta_1$, \; $\mz \Delta_2; B \rightarrow \Delta_2$, \; ... \; $\mz \Delta_n; A_{n-2} \rightarrow \Delta_n$ \hfill (4) induction on (2) \\
$\mz \Delta_1, \Delta_2; A \otimes B \rightarrow \Delta_1, \Delta_2$ \hfill (5) rule on (4) \\
$\mz \Delta_1, \Delta_2; A \otimes B \rightarrow \Delta_1, \Delta_2$ \; ... \; $\mz \Delta_n; A_{n-2} \rightarrow \Delta_n$ \hfill (6) from (5) \\
$\Delta_1, ..., \Delta_n$ is not empty \hfill (7) from induction on (2) \\

\item $\cdot$

$\mo \Delta ; \Xi; \cdot ; H; (\cdot ; \Delta'') \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
$n = 0$ \hfill since $\Omega = \cdot$ \\

\end{itemize}

\subsection{Derive soundness}

If $\done \Delta; \Xi; \Delta_1; \Omega; \cdot \rightarrow \Xi'; \Delta'$ then \\
$\dz \Delta; \Xi; \Delta_1; \Omega \rightarrow \Xi'; \Delta'$

By induction first on $\Omega$ and then on the size of $\Delta$.

\begin{itemize}
\item $p, \Omega$

$\done \Delta; \Xi; \Delta_1; p, \Omega; \cdot \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
$\done \Delta; \Xi; \Delta_1, p; \Omega; \cdot \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
$\dz \Delta; \Xi; \Delta_1, p; \Omega \rightarrow \Xi'; \Delta'$ \hfill (3) by induction on (2) \\
$\dz \Delta; \Xi; \Delta_1; p, \Omega \rightarrow \Xi'; \Delta'$ \hfill (4) rule application on (3) \\

\item $1, \Omega$

Same as before.

\item $A \otimes B, \Omega$

Same as before.

\item $\comp A \lolli B, \Omega$

$\done \Delta; \Xi; \Delta_1; \comp A \lolli B, \Omega; \cdot \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
$\ao \Delta; A \lolli B; (\done \Delta; \Xi; \Delta_1; \comp A \lolli B, \Omega) \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
$\mo \Delta; \cdot; A; B ; (\done \Delta; \Xi; \Delta_1; \comp A \lolli B, \Omega) \rightarrow \Xi'; \Delta'$ \hfill (3) inversion of (2) \\
Using (3) on theorem "Low level comprehension gives one match" we get two subcases:

\begin{itemize}
\item Comprehension fails:

$\cont (\done \Delta; \Xi; \Delta_1; \comp A \lolli B, \Omega); \Xi' \Delta'$ \hfill (4) from theorem \\
$\done \Delta; \Xi; \Delta_1; \Omega; \cdot \rightarrow \Xi'; \Delta'$ \hfill (5) inversion of (4) \\
$\dz \Delta; \Xi; \Delta_1; \Omega \rightarrow \Xi'; \Delta'$ \hfill (6) induction on (5) \\
$\dz \Delta; \Xi; \Delta_1; 1, \Omega \rightarrow \Xi';\Delta'$ \hfill (7) rule on (6) \\
$\dz \Delta; \Xi; \Delta_1; 1 \with (A \lolli B \otimes \comp A \lolli B), \Omega \rightarrow \Xi'; \Delta'$ \hfill (8) rule application on (7) \\
$\dz \Delta; \Xi; \Delta_1; \comp A \lolli B, \Omega \rightarrow \Xi'; \Delta'$ (9) rule application on (8) \\
\item Comprehension succeeds:
$\Delta = \Delta'', \Xi''$ \hfill (4) from theorem \\
$\mo \Delta''; \Xi''; \cdot ; B; (\done \Delta; \Xi; \Delta_1; \comp A \lolli B, \Omega) \rightarrow \Xi'; \Delta'$ \hfill (5) from theorem "Low level comprehension gives one match" \\
$\mz \Xi''; A \rightarrow \Xi''$ \hfill (6) from the same theorem \\
$\Delta''$ is smaller than $\Delta$ \hfill (7) from the same theorem \\
$\done \Delta''; \Xi''; \cdot; B; (\done \Delta; \Xi; \Delta_1; \comp A \lolli B, \Omega) \rightarrow \Xi'; \Delta'$ \hfill (8) inversion of (5) \\
$\done \Delta''; \Xi'', \Xi; \Delta_1; B, \comp A \lolli B, \Omega; \cdot \rightarrow \Xi'; \Delta'$ \hfill (9) using theorem "Comprehension head is another derivation theorem" on (8) \\
$\dz \Delta''; \Xi''; \Xi; \Delta_1; B, \comp A \lolli B, \Omega \rightarrow \Xi'; \Delta'$ \hfill (10) by i.h. on (9) because of (7) \\
$\dz \Xi'', \Delta''; \Xi'; \Delta_1; A \lolli B, \comp A \lolli B, \Omega \rightarrow \Xi'; \Delta'$ \hfill (11) using rule on (10) and (6) \\
$\dz \Xi'', \Delta''; \Xi'; \Delta_1; (A \lolli B) \otimes (\comp A \lolli B), \Omega \rightarrow \Xi'; \Delta'$ \hfill (12) using rule on (11) \\
$\dz \Xi'', \Delta''; \Xi'; \Delta_1; 1 \with ((A \lolli B) \otimes (\comp A \lolli B)), \Omega \rightarrow \Xi'; \Delta'$ \hfill (13) rule on (12) \\
$\dz \Xi'', \Delta''; \Xi'; \Delta_1; \comp A \lolli B, \Omega \rightarrow \Xi'; \Delta'$ \hfill (14) rule on (13) \\

\end{itemize}
\end{itemize}

\subsection{Apply Soundness Theorem}

If $\ao \Delta; R; (\cdot; \Delta) \rightarrow \Xi'; \Delta'$ then \\
      $\az \Delta; R \rightarrow \Xi'; \Delta'$

Case by case analysis:

\begin{itemize}
\item $R = A \lolli B$

$\ao \Delta; A \lolli B ; (\cdot ; \Delta) \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
$\mo \Delta_1, \Delta_2; \cdot; A ; B ; (\cdot ; \Delta) \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
$\mo \Delta_2; \Delta_1; \cdot ; B ; (\cdot ; \Delta) \rightarrow \Xi'; \Delta'$ \hfill (3) using theorem "Low level matching gives high level matching theorem" on (2) \\
$\mz \Delta_1 ; A \rightarrow \Delta_1$ \hfill (4) from same theorem on (2) \\
$\do \Delta_2; \Delta_1; \cdot ; B ; (\cdot ; \Delta) \rightarrow \Xi'; \Delta'$ \hfill (5) inversion of (3) \\
$\dz \Delta_2; \Delta_1; \cdot ; B \rightarrow \Xi'; \Delta'$ \hfill (6) derive soundness on (5) \\
$\az \Delta_1, \Delta_2; A \lolli B \rightarrow \Xi'; \Delta'$ \hfill (7) using rule on (6) and (4) \\
\end{itemize}

\subsection{Success or continuation}

If $\mo \Delta; \Xi; \Delta_1; \Omega; H; (\Phi; \Delta'') \rightarrow \Xi'; \Delta'$ then either:

\begin{itemize}
   \item $\cont \; (\Phi; \Delta''); \Xi'; \Delta'$
   \item $\mo \Delta; \Xi; \Delta_1; \Omega; H; (\cdot; \Delta'') \rightarrow \Xi'; \Delta'$
\end{itemize}

Induction on $\Omega$:

\begin{itemize}
\item $p, \Omega$ and $p \in \Omega$

$\mo \Delta, p; \Xi; p, \Omega; H; (\Phi; \Delta'') \rightarrow \Xi'; \Delta'$ \hfill (1) assumption\\
$\mo \Delta; \Xi, p; \Omega; H; (\Phi; \Delta'') \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1)\\
$\cont \; (\Phi; \Delta'') ; \Xi'; \Delta'$ or $\mo \Delta; \Xi, p; \Omega; H; (\cdot; \Delta'') \rightarrow \Xi'; \Delta'$ \hfill (3) induction of (2) \\
$\cont \; (\Phi; \Delta'') ; \Xi'; \Delta'$ or $\mo \Delta, p; \Xi; p, \Omega; H; (\cdot; \Delta'') \rightarrow \Xi'; \Delta'$ \hfill (4) rule application on (3) \\

\item $p, \Omega$ and $p \notin \Delta$

$\mo \Delta; \Xi; p, \Omega; H; (\Phi; \Delta'') \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
$\cont \; (\Phi; \Delta''); \Xi'; \Delta'$ \hfill (2) inversion of (1) \\

\item $A \otimes B, \Omega$

$\mo \Delta; \Xi; A \otimes B, \Omega; H; (\Phi; \Delta'') \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
$\mo \Delta; \Xi; A, B, \Omega; H; (\Phi; \Delta'') \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
$\cont \; (\Phi; \Delta''); \Xi'; \Delta'$ or $\mo \Delta; \Xi; A, B, \Omega; H; (\cdot; \Delta'') \rightarrow \Xi'; \Delta'$ \hfill (3) i.h. on (2) \\
$\cont \; (\Phi; \Delta''); \Xi'; \Delta'$ or $\mo \Delta; \Xi; A \otimes B, \Omega; H; (\cdot; \Delta'') \rightarrow \Xi'; \Delta'$ \hfill (4) rule on (3) \\

\item $\cdot$

$\mo \Delta; \Xi; \cdot; H; (\Phi; \Delta'') \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
$\done \Delta; \Xi; \cdot; H; \cdot \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
$\mo \Delta; \Xi; \cdot; H; (\cdot; \Delta'') \rightarrow \Xi'; \Delta'$ \hfill (3) rule application on (2) \\
\end{itemize}

\subsection{One Rule Theorem}

If $\doo \Delta; \Phi \rightarrow \Xi'; \Delta'$ then $\exists R \in \Phi. \doo \Delta; R \rightarrow \Xi'; \Delta'$.

Induction on the size of $\Phi$.

\begin{itemize}
\item $\Phi = \cdot$

Not applicable.

\item $\Phi = R', \Phi'$

$\doo \Delta; R', \Phi' \rightarrow \Xi' \Delta'$ \hfill (1) assumption \\
$\ao \Delta; R'; (\Phi'; \Delta) \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
$\mo \Delta; \cdot; A; B; (\Phi'; \Delta) \rightarrow \Xi'; \Delta'$ \hfill (3) inversion of (2) where $R' = A \lolli B$\\

From theorem "Success or continuation" we have two cases:

   \begin{itemize}
   \item Match Success \\
   $\mo \Delta; \cdot; A; B; (\cdot; \Delta) \rightarrow \Xi'; \Delta'$ \hfill (4) from theorem \\
   $\ao \Delta; A \lolli B; (\cdot; \Delta) \rightarrow \Xi'; \Delta'$ \hfill (5) rule application on (4) \\
   $\doo \Delta; A \lolli B \rightarrow \Xi'; \Delta'$ \hfill (6) rule application on (5) \\
   $\doo \Delta; R \rightarrow \Xi'; \Delta'$ \hfill (7) rewrite of (6) \\

   \item Continuation \\
   $\cont (\Phi'; \Delta); \Xi'; \Delta'$ \hfill (4) from theorem \\
   $\doo \Delta; \Phi' \rightarrow \Xi'; \Delta'$ \hfill (5) inversion of (4) \\
   $\exists R \in \Phi'. \doo \Delta; R \rightarrow \Xi'; \Delta'$ \hfill (6) i.h. on (5) \\
   $\exists R \in \Phi.$ \hfill (7) from (6) \\
   \end{itemize}

\end{itemize}

\section{Low Level System With Matching Continuations}

\subsection{Low Level System}

For this system, we include only linear facts but we use a continuation stack to match facts.

\subsubsection{Match}

\[
\infer[ok]
{\mo \Delta, p_1, \Delta'' ; \Xi; p, \Omega; H; C; R \rightarrow \Xi'; \Delta'}
{\mo \Delta, \Delta''; \Xi, p_1; \Omega; H; (\Delta, p_1; \Delta''; p, \Omega; H; \Xi), C; R \rightarrow \Xi'; \Delta'}
\tab
\infer[fail]
{\mo \Delta; \Xi; p, \Omega; H; C; R \rightarrow \Xi'; \Delta'}
{p \notin \Delta & \cont C ; R; \Xi'; \Delta'}
\]

\[
\infer[match \; \otimes]
{\mo \Delta; \Xi; A \otimes B, \Omega ; H ; C; R \rightarrow \Xi'; \Delta'}
{\mo \Delta; \Xi; A, B, \Omega; H; C; R \rightarrow \Xi';\Delta'}
\]

\[
\infer[end]
{\mo \Delta; \Xi; \cdot ; H; C; R \rightarrow \Xi'; \Delta'}
{\done \Delta; \Xi; \cdot ; H; \cdot \rightarrow \Xi'; \Delta'}
\]

\subsubsection{Derive}

\[
\infer[derive \; p]
{\done \Delta; \Xi; \Delta_1; p, \Omega; C \rightarrow \Xi'; \Delta'}
{\done \Delta; \Xi; p, \Delta_1; \Omega; C \rightarrow \Xi'; \Delta'}
\tab
\infer[derive \; 1]
{\done \Delta; \Xi; \Delta_1; 1, \Omega; C \rightarrow \Xi';\Delta'}
{\done \Delta; \Xi; \Delta_1; \Omega; C \rightarrow \Xi'; \Delta'}
\]

\[
\infer[derive \; \otimes]
{\done \Delta; \Xi; \Delta_1; A \otimes B, \Omega; C \rightarrow \Xi'; \Delta'}
{\done \Delta; \Xi; \Delta_1; A, B, \Omega; C \rightarrow \Xi';\Delta'}
\]

\[
\infer[derive \; end]
{\done \Delta; \Xi; \Delta_1; \cdot \rightarrow \Xi; \Delta_1}
{}
\]

\subsubsection{Continuation}

\[
\infer[next \; rule]
{\cont \cdot; (\Phi; \Delta); \Xi'; \Delta'}
{\doo \Delta; \Phi \rightarrow \Xi'; \Delta'}
\]

\[
\infer[cont \; next]
{\cont (\Delta; p_1, \Delta''; p, \Omega; H; \Xi), C; R; \Xi'; \Delta'}
{\mo \Delta, \Delta''; \Xi, p_1; \Omega; H; (\Delta, p_1; \Delta''; p, \Omega; H; \Xi), C; R \rightarrow \Xi'; \Delta'}
\]

\[
\infer[cont \; no \; more]
{\cont (\Delta; \cdot; p, \Omega; H; \Xi), C; R; \Xi'; \Delta'}
{\cont C; R; \Xi'; \Delta'}
\]

\subsubsection{Apply}

\[
\infer[start \; matching]
{\ao \Delta; A \lolli B; R \rightarrow \Xi'; \Delta'}
{\mo \Delta; \cdot; A; B; \cdot; R \rightarrow \Xi'; \Delta'}
\]

\[
\infer[do \; rule]
{\doo \Delta; R, \Phi \rightarrow \Xi'; \Delta'}
{\ao \Delta; R; (\Phi; \Delta) \rightarrow \Xi';\Delta'}
\]

\subsection{High Level System}

\subsubsection{Match}

\[
\infer[match \; 1]
{\mz \cdot ; 1 \rightarrow 1}
{}
\tab
\infer[match \; p]
{\mz p ; p \rightarrow p}
{}
\]

\[
\infer[match \; \otimes]
{\mz \Delta_1, \Delta_2 ; A \otimes B \rightarrow \Xi_1, \Xi_2}
{\mz \Delta_1 ; A \rightarrow \Xi_1 & \mz \Delta_2 ; B \rightarrow \Xi_2}
\]

\subsubsection{Derive}

\[
\infer[derive \; p]
{\dz \Delta ; \Xi ; \Delta_1 ; p, \Omega \rightarrow \Xi' ; \Delta'}
{\dz \Delta ; \Xi ; p, \Delta_1 ; \Omega \rightarrow \Xi' ; \Delta'}
\]

\[
\infer[derive \; \otimes]
{\dz \Delta; \Xi; \Delta_1; A \otimes B, \Omega \rightarrow \Xi'; \Delta'}
{\dz \Delta; \Xi; \Delta_1; A, B, \Omega \rightarrow \Xi'; \Delta'}
\tab
\]

\[
\infer[derive \; end]
{\dz \Delta; \Xi'; \Delta'; \cdot \rightarrow \Xi';\Delta'}
{}
\]

\subsubsection{Apply}

\[
\infer[apply]
{\az \Delta, \Delta''; A \lolli B \rightarrow \Xi'; \Delta'}
{\mz \Delta; A \rightarrow \Delta & \dz \Delta''; \Delta; \cdot ; B \rightarrow \Xi'; \Delta'}
\]

\[
\infer[do \; rule]
{\doz \Delta; R, \Phi \rightarrow \Xi';\Delta'}
{\doz \Delta; R \rightarrow \Xi';\Delta'}
\]

\subsection{Theorems}

% these two theorems used an old system
\begin{comment}
\subsubsection{Continuation structure theorem}

I think we need a constraint at the end of the derivation tree so that the final $\mo$ or $\cont$ uses $\cdot$ as $C$.\\

If $\mo \Delta; \Xi; \Omega; H; C; R \rightarrow \Xi'; \Delta'$ then either \\
1. \hspace{2cm}   $C = \cdot$ or \\
2. \hspace{2cm}   $C = (\Delta_1; \Delta_2; p, \Omega; H; \Xi_1; C'')$ where $\Delta, \Xi = \Delta_1, \Delta_2, \Xi_1$ \\

If $\cont C; R; \Xi'; \Delta'$ then either \\
1. \hspace{2cm}   $C = \cdot$ or \\
2. \hspace{2cm}   $C = (\Delta_1; \Delta_2; p, \Omega; H; \Xi_1; C')$\\

Proof by mutual induction.

\begin{itemize}
   \item ok
   
   $\mo \Delta, p_1, \Delta''; \Xi; p, \Omega; H; C; R \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
   $\mo \Delta, \Delta''; \Xi, p_1; \Omega; H; (\Delta, p_1; \Delta''; p, \Omega; H; \Xi; C); R \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
   $\mo \Delta, p_1, \Delta''; \Xi; p, \Omega; H; \cdot; R \rightarrow \Xi'; \Delta'$ \hfill (3) application of ok rule on (2) \\
   
   \item fail
   
   $\mo \Delta_1, \Delta_2; \Xi; p, \Omega; H; C; R \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
   $\cont C; R; \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
   $C = \cdot$ or $C = (\Delta_1; \Delta_2; q, \Omega; H; \Xi; C'$ \hfill (3) i.h. on (2) \\
   
   \begin{itemize}
      \item $C = \cdot$
      
      $\mo \Delta_1; \Delta_2; p, \Omega; \cdot; R \rightarrow \Xi'; \Delta')$ \hfill (4) rule fail \\
      
      \item $C = (\Delta_1; \Delta_2; q, \Omega; H; \Xi; C'$
      
      $\mo \Delta_1; \Delta_2; \Xi; p, \Omega; H; (\Delta_1; \Delta_2; q, \Omega; H; \Xi; C')$ \hfill (4) rule fail \\
   \end{itemize}
   
   \item $match \otimes$
   
   $\mo \Delta; \Xi; A \otimes B, \Omega; H; C; R \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
   $\mo \Delta; \Xi; A, B, \Omega; H; C; R \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
   $C = \cdot$ or $C = (\Delta_1; \Delta_2; p, \Omega; H; \Xi_1; C'')$ where $\Delta, \Xi = \Delta_1, \Delta_2, \Xi_1$ \hfill (3) i.h. on (2) \\
   
   \begin{itemize}
      \item $C = \cdot$
      
      $\mo \Delta; \Xi; A, B, \Omega; H; \cdot; R \rightarrow \Xi'; \Delta'$ \hfill (4) from (3) \\
      $\mo \Delta; \Xi; A \otimes B, \Omega; H; \cdot; R \rightarrow \Xi'; \Delta'$ \hfill (5) $match \otimes$ on (4) \\
      
      \item $C = (\Delta_1; \Delta_2; p, \Omega; H; \Xi_1; C'')$ where $\Delta, \Xi = \Delta_1, \Delta_2, \Xi_1$
      
      $\mo \Delta; \Xi; A, B, \Omega; H; (\Delta_1; \Delta_2; p, \Omega; H; \Xi_1; C''); R \rightarrow \Xi'; \Delta'$ \hfill (4) from (3) \\
      $\mo \Delta; \Xi; A \otimes B, \Omega; H; (\Delta_1; \Delta_2; p, \Omega; H; \Xi_1; C''); R \rightarrow \Xi'; \Delta'$ \hfill (5) rule $match \otimes$ on (4) \\
      
   \end{itemize}
   
   \item $end$
   
   Trivial by setting $C$ to either $\cdot$ or $(\Delta; ...)$.
   
   \item $next \; rule$
   
   $\cont \cdot; (\Phi; \Delta); \Xi'; \Delta'$ \hfill (1) assumption \\
   
   \item $cont \; next$
   
   
   
\end{itemize}

\subsubsection{First}

If $\mo \Delta; \Xi; \Omega; H; C; R \rightarrow \Xi'; \Delta'$ then either\\
1. \hspace{2cm}   $\mo \Delta''; \Xi''; \cdot; H; C''; R \rightarrow \Xi'; \Delta'$ or \\
2. \hspace{2cm}   $\cont \cdot; R; \Xi'; \Delta'$\\

If $\cont (\Delta; \Delta_1; p, \Omega; H; \Xi; C); R; \Xi'; \Delta'$ then either\\
1. \hspace{2cm}   $\mo \Delta''; \Xi''; \cdot; H; C''; R \rightarrow \Xi'; \Delta'$\\
2. \hspace{2cm}   $\cont \cdot; R; \Xi'; \Delta'$

Proof by mutual induction. On the first "if" induction on $\Omega$ and on the second "if" induction on the size of $\Delta_1$ and the structure of $C$.

\begin{itemize}
\item ok

$\mo \Delta, p_1, \Delta''; \Xi; p, \Omega; H; C; R \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
$\mo \Delta, \Delta''; \Xi, p; \Omega; H; (\Delta, p_1; \Delta''; p, \Omega; H; \Xi; C) ; R \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
$\mo \Delta'''; \Xi''; \cdot; H; C''; R \rightarrow \Xi'; \Delta'$ or $\cont \cdot; R; \Xi'; \Delta'$ \hfill (3) i.h. on (2) \\

\item fail

$\mo \Delta; \Xi; p, \Omega; H; C; R \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
$p \notin \Delta$ \hfill (2) inversion of (1) \\
$\cont C; R; H; \Xi'; \Delta'$ \hfill (3) inversion of (1) \\
C is either $\cdot$ or $(\Delta_1; \Delta_2; p, \Omega; H; \Xi_1; C')$: \hfill (4) from (3) with continuation structure theorem\\

\begin{itemize}
   \item $\cdot$
   
   $\cont \cdot; R; \Xi'; \Delta'$ \hfill (5) from (4)\\
   $\mo \Delta; \Xi; p, \Omega; H; \cdot; R \rightarrow \Xi'; \Delta$ \hfill (6) rule fail on (5) \\
   
   \item $(\Delta_1; \Delta_2; p, \Omega; H; \Xi_1; C')$, where $\Delta, \Xi = \Delta_1, \Delta_2$
   
   $\cont (\Delta_1; \Delta_2; p, \Omega; H; \Xi_1; C'); R; \Xi'; \Delta'$ \hfill (5) from (4) \\
   $\mo \Delta; \Xi; p, \Omega; H; (\Delta_1; \Delta_2; p, \Omega; H; \Xi_1; C'); R \rightarrow \Xi'; \Delta'$ \hfill (6) rule fail on (5) \\
    
\end{itemize}

\item $match \; \otimes$

$\mo \Delta; \Xi; A \otimes B, \Omega; H; C; R \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
$\mo \Delta; \Xi; A, B, \Omega; H; C; R \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
$\mo \Delta''; \Xi''; \cdot; H; C''; R \rightarrow \Xi'; \Delta'$ or $\cont \cdot; R; \Xi'; \Delta'$ \hfill (3) i.h. on (2) \\

\begin{itemize}
   \item $\mo \Delta''; \Xi''; \cdot; H; C''; R \rightarrow \Xi'; \Delta'$
   
   done.
   
   \item $\cont \cdot; R; \Xi'; \Delta'$
   
   done.
\end{itemize}

\item $end$

$\mo \Delta; \Xi; \cdot; H; C; R \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\

\item $next \; rule$

$\cont \cdot; (\Phi; \Delta); \Xi'; \Delta'$ \hfill (1) assumption \\

\item $cont \; next$

$\cont (\Delta; p_1, \Delta''; p, \Omega; H; \Xi; C); R; \Xi'; \Delta'$ \hfill (1) assumption \\
$\mo \Delta, \Delta''; \Xi, p_1; \Omega; H; (\Delta, p_1; \Delta''; p, \Omega; H; \Xi; C); R \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
$\mo \Delta''; \Xi''; \cdot; H; C''; R \rightarrow \Xi'; \Delta'$ or $\cont \cdot; R; \Xi'; \Delta'$ \hfill (3) i.h. on (2) \\

\item $cont \; no \; more$

$\cont (\Delta; \cdot; p, \Omega; H; \Xi; C); R ; \Xi'; \Delta'$ \hfill (1) assumption \\
$\cont C; R; \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
$\mo \Delta''; \Xi''; \cdot; H; C''; R \rightarrow \Xi'; \Delta'$ or $\cont \cdot; R; \Xi'; \Delta'$ \hfill (3) i.h. on (2) \\


\end{itemize}

\end{comment}

\subsubsection{Match soundness theorem}

If $\mo \Delta, \Delta_1, ..., \Delta_n; \Xi; \Omega_1, ..., \Omega_n; H; C; R \rightarrow \Xi'; \Delta'$ then either:\\
1. \hspace{1cm} $\cont \cdot; R; \Xi'; \Delta'$ or \\
2. \hspace{1cm} $\mo \Delta; \Xi, \Delta_1, ..., \Delta_n; \cdot; H; C''; R \rightarrow \Xi'; \Delta'$ and $\mz \Delta_1; \Omega_1 \rightarrow \Delta_1$ ... $\mz \Delta_n; \Omega_n \rightarrow \Delta_n$ or \\
3. \hspace{1cm} $\exists f = (\Delta_a; \Delta_b; \Omega_1, ..., \Omega_n; H; \Xi_a) \in C$ such that:\\
3.1 \hspace{2cm} $\Delta_a, \Delta_b = \Delta_c, \Delta_1, ..., \Delta_n$ and \\
3.2 \hspace{2cm} $\mo \Delta_c; \Xi_a, \Delta_1, ..., \Delta_n; \cdot; H; C''; R \rightarrow \Xi'; \Delta'$ and \\
3.3 \hspace{2cm} $\mz \Delta_1; \Omega_1 \rightarrow \Delta_1$ ... $\mz \Delta_n; \Omega_n \rightarrow \Delta_n$.\\

If $\cont C; R; \Xi'; \Delta'$ then either:\\
1. \hspace{1cm} $\cont \cdot; R; \Xi'; \Delta'$ or \\
2. \hspace{1cm} $\exists f = (\Delta_a; \Delta_b; \Omega_1, ..., \Omega_n; H; \Xi_a) \in C$ such that:\\
2.1 \hspace{2cm} $\Delta_a, \Delta_b = \Delta_c, \Delta_1, ..., \Delta_n$ and \\
2.2 \hspace{2cm} $\mo \Delta_c; \Xi_a, \Delta_1, ..., \Delta_n; \cdot; H; C''; R \rightarrow \Xi'; \Delta'$ and \\
2.3 \hspace{2cm} $\mz \Delta_1; \Omega_1 \rightarrow \Delta_1$ ... $\mz \Delta_n; \Omega_n \rightarrow \Delta_n$.\\

Proof by mutual induction. In $\mo$ on the size of $\Omega$ and on $\cont$ on the size of $C$ and $\Delta''$.

\begin{itemize}
   \item $ok$
   
   By induction.
   
   \item $fail$
   
   $\mo \Delta; \Xi; p, \Omega; H; C; R \rightarrow \Xi'; \Delta'$ \hfill (1) assumption \\
   $\cont C; R; \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
   Apply i.h. on (2) to get $\cont \cdot; R; \Xi'; \Delta'$ or the $\exists f.$.
   
   \item $match \; \otimes$
   
   By induction.
   
   \item $end$
   
   $\mz \Delta; \Xi; \cdot; H; C; R \rightarrow \Xi'; \Delta'$ \hfill (1) assumption.\\
   
   \item $next \; rule$
   
   $\cont \cdot; (\Phi; \Delta); \Xi'; \Delta'$ \hfill (1) assumption \\
   
   \item $cont \; next$ -- some doubts about this one.
   
   $\cont (\Delta; p_1, \Delta''; p, \Omega; H; \Xi), C; R; \Xi'; \Delta'$ \hfill (1) assumption \\
   $\mo \Delta, \Delta''; \Xi, p_1;  \Omega; H; (\Delta, p_1; \Delta''; p, \Omega; H; \Xi), C; R \rightarrow \Xi'; \Delta'$ \hfill (2) inversion of (1)\\
   Induction on (2):
   
   \begin{itemize}
      \item $\cont \cdot; R; \Xi'; \Delta'$
      
      \item $\mo \Delta_a; \Xi, p_1, \Delta_1, ..., \Delta_n; \cdot; H; C''; R \rightarrow \Xi'; \Delta'$ 
      
      where $\Delta_a, \Delta_1, ..., \Delta_n = \Delta, \Delta'$ \\
      
      $\exists f = (\Delta; p_1; \Delta''; p, \Omega; H; \Xi)$
      
      \item $\exists f \in (\Delta, p_1; \Delta''; p, \Omega; H; \Xi), C$
      
      $f$ can be $(\Delta, p_1; \Delta''; p, \Omega; H; \Xi)$ (which is contained in the original $\cont$)\\
      or $f \in C$\\
      
   \end{itemize}
   
   \item $cont \; no \; more$
   
   $\cont (\Delta; \cdot; p, \Omega; H; \Xi), C; R; \Xi'; \Delta'$ \hfill (1) assumption \\
   $\cont C; R; \Xi'; \Delta'$ \hfill (2) inversion of (1) \\
   
   By induction:
   
   \begin{itemize}
      \item $\cont \cdot; R; \Xi'; \Delta'$
      
      \item $\exists f \in C$
      
      Then $\exists f \in (\Delta; \cdot; p, \Omega; H; \Xi), C$ \\
   \end{itemize}
   
\end{itemize}

\subsection{Match Soundness Lemma}

If $\mo \Delta, \Delta''; \cdot; \Omega; H; \cdot; R \rightarrow \Xi'; \Delta'$ then either:\\
1. \hspace{1cm} $\cont \cdot; R; \Xi'; \Delta'$ or \\
2. \hspace{1cm} $\mo \Delta; \Delta''; \cdot; H; C'; R \rightarrow \Xi'; \Delta'$ and\\
2.1 \hspace{2cm} $\mz \Delta''; \Omega \rightarrow \Delta''$\\

Proof: By direct use of the match soundness theorem.

\subsection{Derive Soundness Theorem}

If $\done \Delta; \Xi; \Delta_1; \Omega; C \rightarrow \Xi'; \Delta'$ then $\dz \Delta; \Xi; \Delta_1; \Omega \rightarrow \Xi'; \Delta'$.

By simple induction on $\Omega$.

\begin{itemize}
   \item $derive \; p$
   
   By induction.
   
   \item $derive \; 1$
   
   By induction.
   
   \item $derive \; \otimes$
   
   By induction.
   
   \item $derive \; end$
   
   Use axioms.
   
\end{itemize}

\section{Low Level System With Comprehensions}

\subsection{High Level System}

\subsubsection{Match}

\[
\infer[match \; 1]
{\mz \cdot ; 1 \rightarrow 1}
{}
\tab
\infer[match \; p]
{\mz p ; p \rightarrow p}
{}
\]

\[
\infer[match \; \otimes]
{\mz \Delta_1, \Delta_2 ; A \otimes B \rightarrow \Xi_1, \Xi_2}
{\mz \Delta_1 ; A \rightarrow \Xi_1 & \mz \Delta_2 ; B \rightarrow \Xi_2}
\]

\subsubsection{Derive}

\[
\infer[derive \; p]
{\dz \Delta ; \Xi ; \Delta_1 ; p, \Omega \rightarrow \Xi' ; \Delta'}
{\dz \Delta ; \Xi ; p, \Delta_1 ; \Omega \rightarrow \Xi' ; \Delta'}
\]

\[
\infer[derive \; \otimes]
{\dz \Delta; \Xi; \Delta_1; A \otimes B, \Omega \rightarrow \Xi'; \Delta'}
{\dz \Delta; \Xi; \Delta_1; A, B, \Omega \rightarrow \Xi'; \Delta'}
\tab
\]

\[
\infer[derive \; end]
{\dz \Delta; \Xi'; \Delta'; \cdot \rightarrow \Xi';\Delta'}
{}
\]


\[
\infer[derive \; comp]
{\dz \Delta ; \Xi; \Delta_1; \m{comp} A \lolli B, \Omega \rightarrow \Xi';\Delta'}
{\dz \Delta; \Xi; \Delta_1; 1 \with (A \lolli B \otimes \m{comp} A \lolli B), \Omega \rightarrow \Xi';\Delta'}
\]

\[
\infer[derive \; lolli]
{\dz \Delta_a, \Delta_b; \Xi; \Delta_1; A \lolli B, \Omega \rightarrow \Xi';\Delta'}
{\mz \Delta_a; A \rightarrow \Delta_a & \dz \Delta_b ; \Xi; \Delta_a; \Delta_1; B, \Omega \rightarrow \Xi'; \Delta'}
\]

\[
\infer[derive \; left]
{\dz \Delta; \Xi; \Delta_1; A \with B, \Omega \rightarrow \Xi';\Delta'}
{\dz \Delta; \Xi; \Delta_1; A, \Omega \rightarrow \Xi';\Delta'}
\tab
\infer[derive \; right]
{\dz \Delta; \Xi; \Delta_1; A \with B, \Omega \rightarrow \Xi';\Delta'}
{\dz \Delta; \Xi; \Delta_1; B, \Omega \rightarrow \Xi';\Delta'}
\]

\subsubsection{Apply}

\[
\infer[apply]
{\az \Delta, \Delta''; A \lolli B \rightarrow \Xi'; \Delta'}
{\mz \Delta; A \rightarrow \Delta & \dz \Delta''; \Delta; \cdot ; B \rightarrow \Xi'; \Delta'}
\]

\[
\infer[do \; rule]
{\doz \Delta; R, \Phi \rightarrow \Xi';\Delta'}
{\doz \Delta; R \rightarrow \Xi';\Delta'}
\]

\subsection{Low Level System}

We extend the previous system with comprehensions.

\subsubsection{Match}

\[
\infer[ok]
{\mo \Delta, p_1, \Delta'' ; \Xi; p, \Omega; H; C; R \rightarrow \Xi'; \Delta'}
{\mo \Delta, \Delta''; \Xi, p_1; \Omega; H; (\Delta, p_1; \Delta''; p, \Omega; H; \Xi), C; R \rightarrow \Xi'; \Delta'}
\tab
\infer[fail]
{\mo \Delta; \Xi; p, \Omega; H; C; R \rightarrow \Xi'; \Delta'}
{p \notin \Delta & \cont C ; R; \Xi'; \Delta'}
\]

\[
\infer[match \; \otimes]
{\mo \Delta; \Xi; A \otimes B, \Omega ; H ; C; R \rightarrow \Xi'; \Delta'}
{\mo \Delta; \Xi; A, B, \Omega; H; C; R \rightarrow \Xi';\Delta'}
\]

\[
\infer[end]
{\mo \Delta; \Xi; \cdot ; H; C; R \rightarrow \Xi'; \Delta'}
{\done \Delta; \Xi; \cdot ; H; \cdot \rightarrow \Xi'; \Delta'}
\]

\subsubsection{Derive}

\newcommand{\mc}[0]{\m{mc} \; }

\[
\infer[derive \; p]
{\done \Delta; \Xi; \Delta_1; p, \Omega; C \rightarrow \Xi'; \Delta'}
{\done \Delta; \Xi; p, \Delta_1; \Omega; C \rightarrow \Xi'; \Delta'}
\tab
\infer[derive \; 1]
{\done \Delta; \Xi; \Delta_1; 1, \Omega; C \rightarrow \Xi';\Delta'}
{\done \Delta; \Xi; \Delta_1; \Omega; C \rightarrow \Xi'; \Delta'}
\]

\[
\infer[derive \; \otimes]
{\done \Delta; \Xi; \Delta_1; A \otimes B, \Omega; C \rightarrow \Xi'; \Delta'}
{\done \Delta; \Xi; \Delta_1; A, B, \Omega; C \rightarrow \Xi';\Delta'}
\]

\[
\infer[derive \; end]
{\done \Delta; \Xi; \Delta_1; \cdot \rightarrow \Xi; \Delta_1}
{}
\]

\[
\infer[derive \; comp]
{\done \Delta ; \Xi; \Delta_1; \m{comp} A \lolli B, \Omega \rightarrow \Xi';\Delta'}
{\mc \Delta; \Xi; \Delta_1; \cdot; A ; B ; \cdot; \m{comp} A \lolli B; \Omega \rightarrow \Xi';\Delta'}
\]

\subsubsection{Continuation}

\[
\infer[next \; rule]
{\cont \cdot; (\Phi; \Delta); \Xi'; \Delta'}
{\doo \Delta; \Phi \rightarrow \Xi'; \Delta'}
\]

\[
\infer[cont \; next]
{\cont (\Delta; p_1, \Delta''; p, \Omega; H; \Xi), C; R; \Xi'; \Delta'}
{\mo \Delta, \Delta''; \Xi, p_1; \Omega; H; (\Delta, p_1; \Delta''; p, \Omega; H; \Xi), C; R \rightarrow \Xi'; \Delta'}
\]

\[
\infer[cont \; no \; more]
{\cont (\Delta; \cdot; p, \Omega; H; \Xi), C; R; \Xi'; \Delta'}
{\cont C; R; \Xi'; \Delta'}
\]

\subsubsection{Match Comprehension}

\[
\infer[mc \; p \; ok]
{\mc \Delta, p_1, \Delta''; \Xi_a; \Delta_a; \Xi; p, \Omega; H; C; B; Next \rightarrow \Xi'; \Delta'}
{\mc \Delta, \Delta''; \Xi_a; \Delta_a; \Xi, p_1; \Omega; H; (\Delta, p_1; \Delta''; \Xi; p, \Omega; H), C; B; Next \rightarrow \Xi'; \Delta'}
\]

\[
\infer[mc \; p \; fail]
{\mc \Delta; \Xi_a; \Delta_a; \Xi; p, \Omega; H; C; B; Next \rightarrow \Xi'; \Delta'}
{\contc \Delta; \Xi_a; \Delta_a; C; B; Next \rightarrow \Xi'; \Delta'}
\]

\[
\infer[mc \; \otimes]
{\mc \Delta; \Xi_a; \Delta_a; \Xi; A \otimes B, \Omega; H; C; B; Next \rightarrow \Xi'; \Delta'}
{\mc \Delta; \Xi_a; \Delta_a; \Xi; A, B, \Omega; H; C; B; Next \rightarrow \Xi'; \Delta'}
\]

\[
\infer[mc \; end]
{\mc \Delta; \Xi_a; \Delta_a; \Xi; \cdot; H; C; B; Next \rightarrow \Xi'; \Delta'}
{\m{dall} \; \Delta; \Xi_a; \Delta_a; \Xi; H; C; B; Next \rightarrow \Xi'; \Delta'}
\]

\[
\infer[\m{dall} \; end]
{\m{dall} \; \Delta; \Xi_a; \Delta_a; \Xi; H; (\Delta_x; \Delta''; \Xi_b; p, \Omega; H); B; Next \rightarrow \Xi'; \Delta'}
{\m{dc} \; \Delta; \Xi_a, \Xi; \Delta_a; H; (\Delta_x - (\Xi - \Xi_b); \Delta'' - (\Xi - \Xi_b); \cdot; p, \Omega; H) ; B; Next \rightarrow \Xi'; \Delta'}
\]

\[
\infer[\m{dall} \; more]
{\m{dall} \; \Delta; \Xi_a; \Delta_a; \Xi; H; \_, X, C; B; Next \rightarrow \Xi'; \Delta'}
{\m{dall} \; \Delta; \Xi_a; \Delta_a; \Xi; H; X, C; B; Next \rightarrow \Xi'; \Delta'}
\]

\[
\infer[\m{dc} \; p]
{\m{dc} \; \Delta; \Xi; \Delta_1; p, \Omega; C; B; Next \rightarrow \Xi'; \Delta'}
{\m{dc} \; \Delta; \Xi; \Delta_1, p; \Omega; C; B; Next \rightarrow \Xi'; \Delta'}
\]

\[
\infer[\m{dc} \; \otimes]
{\m{dc} \; \Delta; \Xi; \Delta_1; A \otimes B, \Omega; C; B; Next \rightarrow \Xi'; \Delta'}
{\m{dc} \; \Delta; \Xi; \Delta_1; A, B, \Omega; C; B; Next \rightarrow \Xi'; \Delta'}
\]

\[
\infer[\m{dc} \; end]
{\m{dc} \; \Delta; \Xi; \Delta_1; \cdot; C; B; Next \rightarrow \Xi'; \Delta'}
{\m{contc} \; \Delta; \Xi; \Delta_1; C; B; Next; \rightarrow \Xi'; \Delta'}
\]

\subsubsection{Match Comprehension Continuation}

\[
\infer[contc \; end]
{\contc \Delta; \Xi_a; \Delta_a; \cdot; \comp \; A \lolli B; \Omega \rightarrow \Xi'; \Delta'}
{\done \Delta; \Xi_a; \Delta_a; \Omega \rightarrow \Xi'; \Delta'}
\]

\[
\infer[contc \; next]
{\contc \Delta_x; \Xi_a; \Delta_a; (\Delta; p_1, \Delta''; \Xi; p, \Omega; H), C; B; Next \rightarrow \Xi'; \Delta'}
{\mc \Delta; \Xi_a; \Delta_a; \Xi; \Omega; H; (\Delta, p_1; \Delta''; \Xi; p, \Omega; H), C; B; Next \rightarrow \Xi'; \Delta'}
\]

\[
\infer[contc \; next \; empty]
{\contc \Delta_x; \Xi_a; \Delta_a; (\Delta; \cdot; \Xi; p, \Omega; H), C; B; Next \rightarrow \Xi'; \Delta'}
{\contc \Delta_x; \Xi_a; \Delta_a; C; B; Next \rightarrow \Xi'; \Delta'}
\]

\subsubsection{Apply}

\[
\infer[start \; matching]
{\ao \Delta; A \lolli B; R \rightarrow \Xi'; \Delta'}
{\mo \Delta; \cdot; A; B; \cdot; R \rightarrow \Xi'; \Delta'}
\]

\[
\infer[do \; rule]
{\doo \Delta; R, \Phi \rightarrow \Xi'; \Delta'}
{\ao \Delta; R; (\Phi; \Delta) \rightarrow \Xi';\Delta'}
\]


\section{Low Level System With Persistent Facts}

\section{Low Level System With Aggregates}


\begin{comment}
\section{Soundness}

If $\Psi; \Theta ; \Phi ; \Gamma ; \Delta \hookrightarrow \Gamma' ; \Delta'; \Xi'$ then $\Psi; \Theta, \Phi ; \Gamma; \Delta \Rightarrow \Gamma' ; \Delta' ; \Xi'$.


If $\m{apply1} \; \Psi; \Gamma ; \Delta; [R]; (\m{rule}; \cdot; \cdot; \Delta) \rightarrow \Gamma'; \Delta'; \Xi'$ then $\m{apply} \; \Psi; \Gamma; \Delta, [R] \rightarrow \Gamma'; \Delta'; \Xi'$.

Induction on the first judgment:

\begin{description}

\item[Forall Case:]

$\m{apply1} \; \Psi; \Gamma; \Delta; [\forall X : \tau. A]; (\m{rule}; ...) \rightarrow \Gamma'; \Delta'; \Xi'$ \hfill (1) assumption \\
$\m{apply1} \; \Psi; \Gamma; \Delta; [A\{M/X\}]; (\m{rule}; ...) \rightarrow \Gamma'; \Delta' ; \Xi' $ \hfill (2) inversion of (1) \\
$\val{M}{\tau}$   \hfill (3) inversion of (1) \\
$\m{apply} \; \Psi; \Gamma; \Delta, [A\{M/X\}] \rightarrow \Gamma'; \Delta'; \Xi'$ \hfill (4) i.h. on (2) \\
$\m{apply} \; \Psi ; \Gamma; \Delta, [\forall X: \tau. A] \rightarrow \Gamma'; \Delta'; \Xi'$ \hfill (5) rule on (4) and (3) \\

\item[Lolli Case:]

$\m{apply1} \; \Psi ; \Gamma; \Delta; [A \lolli B]; (\m{rule} ; ...) \rightarrow \Gamma'; \Delta'; \Xi'$ \hfill (1) assumption \\
$\m{matchbody} \; \Psi; \Gamma; \Delta; \cdot ; A ; \cdot ; B ; (\cdot, (\m{rule}; ...)) \rightarrow \Gamma'; \Delta'; \Xi'$ \hfill (2) inversion of (1) \\
$\m{derive1} \; \Psi; \Gamma; \Delta_2; \cdot; \cdot; B; (\cdot, (\m{rule}; ...)) \rightarrow \Gamma'; \Delta'; \Xi'$ \hfill (3) some theorem on (2) \\
$\m{derive} \; \Psi; \Gamma; \Delta_2; B; \cdot; \cdot \rightarrow \Gamma'; \Delta'; (\Xi' - \cdot)$ \hfill (4) derive theorem on (3) \\
$\m{match} \; \Psi; \Gamma; \Delta_1 \rightarrow [A]; \Delta_1$ \hfill (5) theorem on (2), $\Delta_1 \subset \Xi'$ \\
$\m{apply} \; \Psi; \Gamma; \Delta_1, \Delta_2 ; [A \lolli B] \rightarrow \Gamma'; \Delta'; \Xi'$ \hfill (6) using (4) and (5) \\
\end{description}


\subsection{Derive theorem}

If $\m{derive1} \; \Psi; \Gamma; \Delta; \Xi; \Gamma_1 ; \Delta_1; \Omega ; \cdot \rightarrow \Gamma' ; \Delta' ; \Xi'$ then $\m{derive} \; \Psi ; \Gamma ; \Delta; \Omega; \Delta_1; \Gamma_1 \rightarrow \Gamma'; \Delta'; (\Xi' - \Xi)$. \\

Induction on the first judgment.

\begin{description}
\item[Case:] $\m{derive1} \; \Psi ; \Gamma; \Delta; \Xi; \Gamma_1 ; \Delta_1 ; A \otimes B, \Omega ; \cdot \rightarrow \Gamma' ; \Delta' ; \Xi'$

$\m{derive1} \; \Psi ; \Gamma ; \Delta; \Xi; \Gamma_1; \Delta_1 ; A, B, \Omega ; \cdot \rightarrow \Gamma' ; \Delta' ; \Xi'$ \hfill (1) inversion \\
$\m{derive} \; \Psi ; \Gamma ; \Delta ; A, B, \Omega ; \Delta_1 ; \Gamma_1 \rightarrow \Gamma'; \Delta'; (\Xi' - \Xi)$ \hfill (2) i.h. on (1) \\
$\m{derive} \; \Psi ; \Gamma ; \Delta ; A \otimes B, \Omega ; \Delta_1 ; \Gamma_1 \rightarrow \Gamma'; \Delta' ; (\Xi' - \Xi)$ \hfill rule applied to (2) \\

\item[Case:] $\m{derive1} \; \Psi ; \Gamma ; \Delta; \Xi; \Gamma_1 ; \Delta_1; \exists X:\m{addr}, \Omega; \cdot \rightarrow \Gamma'; \Delta' ; \Xi'$

Same as the previous case.

\item[Case:] $\m{derive1} \; \Psi ; \Gamma ; \Delta; \Xi; \Gamma_1 ; \Delta_1; 1, \Omega; \cdot \rightarrow \Gamma'; \Delta' ; \Xi'$

Same as the previous case.

\item[Case:] $\m{derive1} \; \Psi ; \Gamma ; \Delta; \Xi; \Gamma_1 ; \Delta_1; \fact{name}{e_1}{e_2, ..., e_n}, \Omega; \cdot \rightarrow \Gamma'; \Delta' ; \Xi'$

Same as the previous case.

\item[Case:] $\m{derive1} \; \Psi ; \Gamma ; \Delta; \Xi; \Gamma_1 ; \Delta_1; \bang\fact{name}{e_1}{e_2, ..., e_n}, \Omega; \cdot \rightarrow \Gamma'; \Delta' ; \Xi'$

Same as the previous case.

\item[Case:] $\m{derive1} \; \Psi ; \Gamma; \Delta ; \Xi; \Gamma_1; \Delta_1 ; \cdot ; \cdot \rightarrow \Gamma_1; \Delta_1; \Xi$

$\m{derive} \; \Psi; \Gamma; \Delta; \cdot ; \Delta_1; \Gamma_1 \rightarrow \Gamma_1; \Delta_1; (\Xi - \Xi)$ \hfill using axiom \\


\end{description}
\end{comment}


\end{document}

